{"version":3,"sources":["opcua-iiot-response.js"],"names":["module","exports","RED","require","install","coreResponse","nodes","registerType","config","OPCUAIIoTResponse","createNode","this","name","compressStructure","showStatusActivities","showErrors","activateUnsetFilter","activateFilters","negateFilter","node","bianco","core","createBiancoIIoT","assert","iiot","fill","shape","text","handleBrowserMsg","msg","analyzeBrowserResults","handleCrawlerMsg","analyzeCrawlerResults","compressCrawlerMessageStructure","compressReadMessageStructure","analyzeReadResults","analyzeWriteResults","handleListenerMsg","compressListenMessageStructure","handleMethodMsg","analyzeMethodResults","handleDefaultMsg","payload","handlePayloadStatusCode","compressDefaultMessageStructure","handleNodeTypeOfMsg","message","Object","assign","nodetype","handleReadMsg","handleWriteMsg","extractReadEntriesFromFilter","filteredValues","length","forEach","itemIsNotToFilter","item","filteredEntries","push","index","nodesToRead","filter","includes","extractBrowserEntriesFromFilter","extractCrawlerEntriesFromFilter","crawlerResults","outputArguments","results","dataType","arrayType","extractMethodEntriesFromFilter","filterMsg","isNodeTypeToFilterResponse","extractEntries","on","compressed","filters","send","internalDebugLog","err","error","result","checkItemForUnsetState","element","checkResponseItemIsNotToFilter"],"mappings":"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","file":"../opcua-iiot-response.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2017,2018,2019 - Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * Response analyser Node-RED node for OPC UA IIoT nodes.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreResponse = require('./core/opcua-iiot-core-response')\n\n  function OPCUAIIoTResponse (config) {\n    RED.nodes.createNode(this, config)\n    this.name = config.name\n    this.compressStructure = config.compressStructure\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.activateUnsetFilter = config.activateUnsetFilter\n    this.activateFilters = config.activateFilters\n    this.negateFilter = config.negateFilter\n    this.filters = config.filters\n\n    let node = this\n    node.bianco = coreResponse.core.createBiancoIIoT()\n    coreResponse.core.assert(node.bianco.iiot)\n\n    node.status({ fill: 'green', shape: 'ring', text: 'active' })\n\n    node.bianco.iiot.handleBrowserMsg = function (msg) {\n      coreResponse.analyzeBrowserResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressBrowseMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleCrawlerMsg = function (msg) {\n      coreResponse.analyzeCrawlerResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressCrawlerMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleReadMsg = function (msg) {\n      coreResponse.analyzeReadResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressReadMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleWriteMsg = function (msg) {\n      coreResponse.analyzeWriteResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressWriteMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleListenerMsg = function (msg) {\n      coreResponse.analyzeListenerResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressListenMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleMethodMsg = function (msg) {\n      coreResponse.analyzeMethodResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressMethodMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleDefaultMsg = function (msg) {\n      if (msg && msg.payload) {\n        coreResponse.handlePayloadStatusCode(node, msg)\n        if (node.compressStructure) {\n          coreResponse.compressDefaultMessageStructure(msg)\n        }\n      }\n      return msg\n    }\n\n    node.bianco.iiot.handleNodeTypeOfMsg = function (msg) {\n      let message = Object.assign({}, msg)\n\n      switch (msg.nodetype) {\n        case 'browse':\n          message = node.bianco.iiot.handleBrowserMsg(message)\n          break\n        case 'crawl':\n          message = node.bianco.iiot.handleCrawlerMsg(message)\n          break\n        case 'read':\n          message = node.bianco.iiot.handleReadMsg(message)\n          break\n        case 'write':\n          message = node.bianco.iiot.handleWriteMsg(message)\n          break\n        case 'listen':\n          message = node.bianco.iiot.handleListenerMsg(message)\n          break\n        case 'method':\n          message = node.bianco.iiot.handleMethodMsg(message)\n          break\n        default:\n          message = node.bianco.iiot.handleDefaultMsg(message)\n      }\n\n      return message\n    }\n\n    node.bianco.iiot.extractReadEntriesFromFilter = function (message) {\n      let filteredEntries = []\n      let filteredValues = []\n\n      if (message.payload && message.payload.length) {\n        message.payload.forEach((item, index) => {\n          if (node.bianco.iiot.itemIsNotToFilter(item)) {\n            filteredEntries.push(item)\n            filteredValues.push(index)\n          }\n        })\n      }\n\n      if (message.nodesToRead) {\n        message.nodesToRead = message.nodesToRead.filter((item, index) => {\n          return filteredValues.includes(index)\n        })\n      }\n\n      return filteredEntries\n    }\n\n    node.bianco.iiot.extractBrowserEntriesFromFilter = function (message) {\n      let filteredEntries = []\n      message.payload.browserResults.forEach((item) => {\n        if (node.bianco.iiot.itemIsNotToFilter(item)) {\n          filteredEntries.push(item)\n        }\n      })\n      return filteredEntries\n    }\n\n    node.bianco.iiot.extractCrawlerEntriesFromFilter = function (message) {\n      let filteredEntries = []\n      message.payload.crawlerResults.forEach((item) => {\n        if (node.bianco.iiot.itemIsNotToFilter(item)) {\n          filteredEntries.push(item)\n        }\n      })\n      return filteredEntries\n    }\n\n    node.bianco.iiot.extractPayloadEntriesFromFilter = function (message) {\n      let filteredEntries = []\n      message.payload.forEach((item) => {\n        if (node.bianco.iiot.itemIsNotToFilter(item)) {\n          filteredEntries.push(item)\n        }\n      })\n      return filteredEntries\n    }\n\n    node.bianco.iiot.extractMethodEntriesFromFilter = function (message) {\n      let filteredEntries = []\n      let filteredValues = []\n      message.addressSpaceItems.forEach((item, index) => {\n        if (node.bianco.iiot.itemIsNotToFilter(item)) {\n          filteredEntries.push(item)\n          filteredValues.push(index)\n        }\n      })\n\n      let outputArguments = null\n      if (message.payload.results) {\n        outputArguments = message.payload.results.outputArguments\n      } else {\n        outputArguments = message.payload.outputArguments\n      }\n\n      if (outputArguments) {\n        outputArguments.forEach((item, index) => {\n          if (node.bianco.iiot.itemIsNotToFilter(item)) {\n            if (filteredValues.includes(index)) {\n              filteredEntries[index].dataType = item.dataType\n              filteredEntries[index].arrayType = item.arrayType\n              filteredEntries[index].value = item.value\n            }\n          }\n        })\n      }\n\n      return filteredEntries\n    }\n\n    node.bianco.iiot.extractEntries = function (message) {\n      switch (message.nodetype) {\n        case 'read':\n          return node.bianco.iiot.extractReadEntriesFromFilter(message)\n        case 'browse':\n          return node.bianco.iiot.extractBrowserEntriesFromFilter(message)\n        case 'crawl':\n          return node.bianco.iiot.extractCrawlerEntriesFromFilter(message)\n        case 'method':\n          return node.bianco.iiot.extractMethodEntriesFromFilter(message)\n        default:\n          return node.bianco.iiot.extractPayloadEntriesFromFilter(message)\n      }\n    }\n\n    node.bianco.iiot.filterMsg = function (msg) {\n      if (msg.payload.length || coreResponse.core.isNodeTypeToFilterResponse(msg)) {\n        let filteredEntries = node.bianco.iiot.extractEntries(msg)\n        if (filteredEntries.length) {\n          msg.payload = filteredEntries\n          return msg\n        }\n      } else {\n        if (node.bianco.iiot.itemIsNotToFilter(msg.payload)) {\n          return msg\n        }\n      }\n      return null\n    }\n\n    node.on('input', function (msg) {\n      try {\n        if (node.activateUnsetFilter) {\n          if (msg.payload === void 0 || msg.payload === null || msg.payload === {}) { return }\n        }\n\n        let message = node.bianco.iiot.handleNodeTypeOfMsg(msg)\n        message.compressed = node.compressStructure\n\n        if (node.activateFilters && node.filters && node.filters.length > 0) {\n          message = node.bianco.iiot.filterMsg(message)\n          if (message) {\n            node.send(message)\n          }\n        } else {\n          node.send(message)\n        }\n      } catch (err) {\n        coreResponse.internalDebugLog(err)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      }\n    })\n\n    node.bianco.iiot.itemIsNotToFilter = function (item) {\n      let result = coreResponse.core.checkItemForUnsetState(node, item)\n\n      node.filters.forEach((element) => {\n        result = coreResponse.core.checkResponseItemIsNotToFilter(node, item, element, result)\n      })\n\n      return (node.negateFilter) ? !result : result\n    }\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Response', OPCUAIIoTResponse)\n}\n"]}