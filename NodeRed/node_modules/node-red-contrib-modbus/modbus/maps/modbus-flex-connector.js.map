{"version":3,"sources":["modbus-flex-connector.js"],"names":["module","exports","RED","require","install","internalDebugLog","node","registerType","nodes","createNode","this","config","name","maxReconnectsPerMinute","emptyQueue","showStatusActivities","showErrors","settings","connection","mbBasics","getNode","server","modbusClient","initModbusClientEvents","onConfigDone","msg","onConfigError","err","message","error","nodeStatus","statusText","payload","send","on","emptyMsgOnFail","invalidPayloadIn","client","setNodeStatusTo","actualServiceState","connectorType","JSON","stringify","Error"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,QAAAA,CAAA,gCA2EMG,EAAAA,MAAIC,aAAJ,wBA1ENJ,SAA8BC,GAK5BF,EAAIM,MAAMC,WAAWC,KAAMC,GAE3BD,KAAKE,KAAOD,EAAOC,KALrBF,KAAML,uBAA2BM,EAARE,wBAAiB,EAOxCH,KAAKI,WAAaH,EAAOG,WAL3BJ,KAAAK,qBAA8BJ,EAAQI,qBACpCb,KAAIM,WAAMC,EAAVO,WAEAN,KAAKE,WAAa,KAElBF,KAAKI,iBAAmBT,EACxBK,KAAKK,eAAAA,EAALE,SAAmCF,QAEnC,IAAKG,EAAAA,KAELC,EAAKd,gBAAmBA,UAAAA,GAGxB,IAAMC,EAANJ,EAAAM,MAAAY,QAAAT,EAAAU,QACAF,IAGAG,EAAKA,kBAAchB,GACjBa,EAAAI,uBAAAjB,EAAAgB,GAKFhB,EAAKkB,aAAe,SAAUC,GAH9BH,EAAAA,sBACAH,EAASI,gBAAAA,cAA6BD,GAEtChB,EAAKkB,cAAe,UAClBlB,EAAIA,KAAKS,IAOXT,EAAKoB,cAAgB,SAAUC,EAAKF,GAJlCA,EAAAE,EAAoBC,SAChBtB,EAAJU,YALFV,EAAAuB,MAAAF,EAAAF,GASEpB,GAAAA,EAAAA,QAMEoB,EAAII,MAAQF,EAJZrB,EAAIuB,MAAOF,IAAKF,MAAhBE,GAQFF,EAAII,MAAMC,WAAaxB,EAAKyB,WAJ1BN,EAAII,iBADNJ,EAAAO,QAEO,IASP1B,EAAK2B,KAAKR,IAJVnB,EAAA4B,GAAI5B,QAAK6B,SAAgBV,GACvBA,IAAAA,EAAAW,iBAAAX,IAdJH,EAAAe,OA0BI,GAJA/B,EAAAS,sBACDI,EAAAmB,gBAAAhB,EAAAiB,mBAAAjC,GAGCmB,EAAAO,QAAAQ,cACDnC,EAAA,qBAAAoC,KAAAC,UAAAjB,EAAAO,UAQCP,EAAIO,QAAQlB,WAAaR,EAAKQ,WANhCQ,EAASP,KAAAA,mBAAsBU,EAAAnB,EAAAkB,aAAAlB,EAAAoB,mBAC7BP,CACD,IAAAU,EAAA,IAAAc,MAAA,sCAQCrC,EAAKuB,MAAMA,EAAOJ,GALlBpB,EAAAA,KAAAA","file":"../modbus-flex-connector.js","sourcesContent":["/**\n Copyright (c) 2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:flex:connector')\n\n  function ModbusFlexConnector (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.maxReconnectsPerMinute = config.maxReconnectsPerMinute || 4\n    this.emptyQueue = config.emptyQueue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onConfigDone = function (msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('config done', node)\n      }\n      msg.config_change = 'emitted'\n      node.send(msg)\n    }\n\n    node.onConfigError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      if (err && err.message) {\n        msg.error = err\n      } else {\n        msg.error = new Error(err)\n      }\n      msg.error.nodeStatus = node.statusText\n\n      if (node.emptyMsgOnFail) {\n        msg.payload = ''\n      }\n\n      node.send(msg)\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n\n      if (msg.payload.connectorType) {\n        internalDebugLog('dynamicReconnect: ' + JSON.stringify(msg.payload))\n        msg.payload.emptyQueue = node.emptyQueue\n        modbusClient.emit('dynamicReconnect', msg, node.onConfigDone, node.onConfigError)\n      } else {\n        const error = new Error('Payload Not Valid - Connector Type')\n        node.error(error, msg)\n\n        node.send(msg)\n      }\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-connector', ModbusFlexConnector)\n}\n"]}