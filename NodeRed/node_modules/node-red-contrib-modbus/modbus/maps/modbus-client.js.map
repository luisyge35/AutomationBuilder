{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","require","install","coreModbusClient","coreModbusQueue","nodes","registerType","config","mbBasics","createNode","this","ModbusRTU","serialConnectionDelayTimeMS","reconnectTimeMS","unlimitedListeners","defaultUnitId","clienttype","undefined","timeoutTimeMS","queueLogEnabled","stateLogEnabled","tcpHost","tcpPort","parseInt","tcpType","serialDatabits","serialPort","serialBaudrate","serialStopbits","serialConnectionDelay","serialType","unit_id","commandDelay","minCommandDelayMilliseconds","clientTimeout","reconnectOnTimeout","parallelUnitIdsAllowed","node","verboseWarn","logMessage","serverInfo","verbose","warn","settings","internalDebug","isFirstInitOfConnection","closingModbus","Map","client","bufferCommandList","sendingAllowed","messagesAllowedStates","unitSendingAllowed","stateMachine","stateService","createStateMachineService","actualServiceState","actualServiceStateBefore","reconnectTimeoutId","setUnitIdFromPayload","msg","getActualUnitId","unitId","checkUnitId","verboseLog","bufferCommands","state","value","stateLog","setTimeout","connectClient","reconnectTimeout","err","payload","logHintText","emit","matches","serialSendingAllowed","checkQueuesAreEmpty","send","close","message","connectC701","port","autoOpen","error","Error","connectTelnet","then","setTCPConnectionOptions","modbusTcpErrorHandling","connectTcpRTUBuffered","setTCPConnected","connectTCP","serialPortOptions","baudRate","dataBits","stopBits","parity","connectAsciiSerial","setSerialConnectionOptions","serialParity","connectRTUBuffered","modbusSerialErrorHandling","setID","modbusSerialDebug","openSerialClient","JSON","stringify","networkErrors","includes","errno","showErrors","_port","on","onModbusClose","cb","cberr","indexOf","pushToQueueByUnitId","queueLength","get","queueUnitId","length","info","writeModbus","queueLog","readModbus","Promise","reject","invalidPayloadIn","setNewNodeSettings","setMaxListeners","done","name","isOpen","modbusNode","registeredNodeList","id","Object","keys","closeConnectionWithoutRegisteredNodes","deregisterForModbus","auth","needsPermission","req","res","list","ports","json"],"mappings":"aAeAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,6BAIMG,EAAkBH,QAAQ,4BA6hBzBD,EAAAK,MAVDC,aAUO,gBA3hBb,SAA2BC,GAJ3BP,EAAMQ,MAAQC,WAAWC,KAAAH,GAQvB,IAAMI,EAAYV,QAAQ,iBAKpBW,EAA8B,IAE9BC,EAAkB,IALlBC,EAAAA,gCAENJ,KAAMK,WAAaR,EAAnBS,gBAEAC,IAAMC,EAAAA,uBACNR,KAAMG,gBAAkB,EAGxBH,KAAKM,eAAmBT,EAACS,eAGvBN,KAAAS,gBAAAZ,EAAAY,gBACDT,KAFDU,gBAEOb,EAAAa,gBAENV,KAAAW,QAAAd,EAAAc,QAMDX,KAAKY,QAAUC,SAAShB,EAAOe,UAAY,IAJ3CZ,KAAKS,QAAAA,EAALK,QAGAd,KAAKW,WAAUd,EAAOc,WACtBX,KAAKY,eAAUC,EAAShB,eACxBG,KAAKc,eAAiBA,EAAtBC,eAEAf,KAAKgB,eAAanB,EAAOmB,eACzBhB,KAAKiB,aAALpB,EAAsBA,aACtBG,KAAKe,WAAAA,EAAiBlB,WACtBG,KAAKkB,sBAAwBA,SAAAA,EAA7BC,wBAAAjB,EAEAF,KAAKoB,QAALP,SAAwBhB,EAACuB,UAjCJ,EAkCrBpB,KAAKmB,aAAAA,SAAwBN,EAAAA,eAnCI,EAqCjCb,KAAKqB,cAAUR,SAAehB,EAACwB,gBAjCb9B,IAkClBS,KAAKsB,iBAAeT,SAAShB,EAAOyB,mBAAiBC,EACrDvB,KAAKwB,mBAAgBX,EAAShB,wBAEG4B,IAAjC5B,EAAK4B,uBAGHzB,KAAK0B,wBAAyB,EAA9B1B,KAAK0B,uBAAyB7B,EAA9B6B,uBAGD,IAAAC,EAAA3B,KA2CD,SAAS4B,EAAaC,GAHhBvC,EAACwC,SAALC,SANFJ,EAAAK,KAAA,aAAAH,EAAAF,EAAAG,YAWIH,SAAKK,EAAKH,GACXvC,EAAA2C,SAAAF,SACFtC,EAAAyC,cAAA,aAAAL,EAAAF,EAAAG,YA5CDH,EAAKQ,yBAA0B,EAD/BR,EAAMA,eAAN,EACAA,EAAKQ,OAAAA,KACLR,EAAKS,kBAAgB,IAArBC,IACAV,EAAKW,eAAL,IAAAD,IACAV,EAAKY,mBAAoB,GACzBZ,EAAKa,qBAAqBH,EAA1BI,sBACAd,EAAKe,WAAAA,GAELf,EAAKG,aAAL,KAEAH,EAAKgB,aAAe,KACpBhB,EAAKiB,aAAenD,EAApBoD,4BACAlB,EAAKgB,mBAAelD,EAAAA,aAAiBoD,aACrClB,EAAKmB,yBAA0BH,EAAAA,mBAC/BhB,EAAKoB,aAAAA,EAAgCD,kBAArCnB,EAAAgB,cACAhB,EAAKiB,mBAAenD,EACpBkC,EAAKqB,sBAAL,EAGArB,EAAKsB,qBAAuB,SAAUC,GAAtCvB,IAAKsB,EAAAA,EAAuBE,gBAAexB,EAAAuB,GACnCE,EAAS3D,YAAiB0D,EAAAA,EAAgBxB,cAE9CA,EAAKN,QAtEY,GAsEjBM,EAAAA,OAAKN,MAAUhB,GAChB6C,EAAAE,OAAAA,IAEDF,OAAIE,MAASA,EAAb/B,UAAA5B,EAAA4D,YAAA1B,EAAAN,QAAAM,EAAArB,cANFqB,EAAAN,QAnEqB,GA6EnBM,EAAAA,iBAAetB,WAChB,QAAAsB,EAAArB,WAIGqB,EAAKG,WAAa,QAAUH,EAAKhB,QAAU,IAAMgB,EAAKf,QADxDe,EAAIA,WAAA,WAA2BA,EAAAX,WAAA,IAAAW,EAAAV,eAAA,QAE9BU,EAFDG,YAEO,qBAAAH,EAAAN,SAoBLiC,EAAAA,SAAWzB,SAAXA,GACDF,EAAA4B,gBAAA5B,EAAAlB,iBACF6C,EAAAzB,IAIGyB,EAAAA,aAAWzB,UAAX,SAAA2B,GAZA/D,IAAAA,EAiBFkC,GAJCA,EAAAoB,yBAAApB,EAAAmB,mBAHHnB,EAAAmB,mBAAAU,EAVI/D,EAmBO+D,EAAMC,MAlBd9B,EAAAjB,iBACF4C,EAAAzB,GAeK2B,EAACT,QAAAA,QAAAA,CACLpB,EAAKmB,mBACLY,EAAeD,UAAf9B,GAKEA,EAAKqB,mBAAqB,EAF1BrB,IACAjC,EAAAA,yBACIiC,EAACqB,yBAAL,EAKIpB,EAAY,kBAHZ+B,WAAAhC,EAAAiC,cAAA1D,KAEAyB,EAAKQ,WAAAA,EAAL0B,iBAAA,OACAjC,WAAWD,EAACiC,cAAa1D,EAAAA,mBAE1B,MAAM4D,GACLlC,EAAAA,MAAAA,EAAY,CAAAmC,QAAapC,2BAAdqC,IAGdrC,EAACsC,KAAOH,UACSN,EAAhBU,QAAA,eACDvC,EAAAwC,sBAAA,EAODxC,EAAKsC,KAAK,gBAGRT,EAAMU,QAAQ,eALlBvC,EAAI6B,KAAMU,YACJvC,EAACwC,iBAAuBzE,EAA5B0E,oBAAAzC,IACAA,EAAKsC,aAAKI,KAAV,UAIA1C,EAAKsC,QAAK,cAOVtC,EAAKiB,aAAayB,KAAK,QANvBV,WAASJ,WACP5B,EAAKiB,eAALjB,IACDA,EAAAL,cACFK,EAAAsC,KAAA,YAGCtC,EAAKiB,QAAAA,YACLe,EAAAA,sBAAiB,EACfjE,EAAAA,KAAAA,WAGH8D,EAAAU,QAAA,YAQCvC,EAAKsC,KAAK,YANZtC,EAAI6B,aAAca,KAAA,cAGjBb,EAAAU,QAAA,aAQCtC,EAAY,sCANdD,EAAI6B,KAAMU,aAGTV,EAAAU,QAAA,YAQCvC,EAAKsC,KAAK,UAAW,2BAA6BtC,EAAKoB,yBAAyBU,MAAQO,GAN1FrC,EAAI6B,aAAca,KAAA,UAGjBb,EAAAU,QAAA,YAQCvC,EAAKsC,KAAK,WAAY,0BAA4BtC,EAAKoB,yBAAyBU,MAAQO,GANtFR,EAAMU,oBACHD,EAAKJ,kBAAW,IACjBlC,EAACiB,iBAAkBzC,GASrBwB,EAAKiB,aAAayB,KAAK,cALzB1C,EAAKsC,aAALI,KAAsB,aAGlB1C,EAAIuC,QAACL,kBACNlC,EAAAwC,sBAAA,EASHxC,EAAKsC,KAAK,kBARRtC,EAAKiB,kBAAkB,IAJzBjB,EAKOkC,iBAAA1D,GAENwD,WAAA,WACFhC,EAAAqB,mBAAA,EAUGrB,EAAKiB,aAAayB,KAAK,SARvBb,EAAMU,qBAGRvC,EAAAiC,cAASC,WACPlC,GAAAA,EAAKkC,OACN,IAWClC,EAAKW,OAAOgC,MAAM,WAVpBX,EAAW,uBAEThC,EAAKiB,yBAFG,MAGFiB,GACTP,EAAAQ,EAAAS,SAyBD,GAtBF5C,EAAKiC,OAAAA,KACHjC,EAAIA,OAAKW,IAAQrC,EAEb0B,EAAKW,gBACHgB,EAAAA,cA7MU/D,KAgNZoC,EAAAkC,mBACAP,EAAAA,iBAAUnD,GAcU,QAApBwB,EAAKrB,WAAsB,CAX/BqB,IAAKW,EAALe,YAAA1B,EAAAN,QAAAM,EAAArB,YAGI,OAFAqB,EAACW,MAAS,IAAIrC,MAAAA,0BAAlB,CAAA8D,QAAApC,EAAAN,eAaIM,EAAKiB,aAAayB,KAAK,WAIzB,OAAQ1C,EAAKb,SAXX,IAAK,OACHwC,EAACO,wBACNlC,EAAAW,OAAAkC,YAAA7C,EAAAhB,QAAA,CAaO8D,KAAM9C,EAAKf,QAXX8D,UAACpE,IACFb,KAAAA,EAAAA,yBACEkF,KAALhD,EAAeiD,iBAJlB,MAI8DjD,EAAKN,wBAAhE,MACAM,IAAKiB,SACLU,EAAA,eACD3B,EAAAW,OAAAuC,cAAAlD,EAAAhB,QAAA,CAeK8D,KAAM9C,EAAKf,QAbjB8D,UAAa5D,IACNgE,KAAAnD,EAALoD,yBAHD,MAIGzB,EAAW0B,wBACXrD,MACE8C,IAAAA,mBACAC,EAAQ,yBAF4B/C,EAGnCmD,OAASG,sBAACF,EACVD,QAAUI,CAEbT,KAAA9C,EAAAf,QAaE8D,UAAU,IAZTI,KAAAnD,EAALoD,yBAPwC,MAQtCzB,EAAW0B,wBACXrD,MACE8C,QACAC,EAAQ,YAF8B/C,EAGrCmD,OAASK,WAACJ,EAAAA,QAHb,CAKAN,KAAA9C,EAAAf,QAaE8D,UAAU,IAZTI,KAAAnD,EAAAoD,yBANqC,MAOxCzB,EAAW0B,6BAETP,CACAC,IAAAA,EAAUrB,YAAA1B,EAAAN,QAAAM,EAAArB,YAgBd,OAlBkDqB,EAG7CmD,MAAKnD,IAAKoD,MAAAA,iCACCC,CAAAA,QAAAA,EAAAA,eACdrD,EAAAiB,aAAAyB,KAAA,WAzBJ,GA4BI1C,EAAKW,wBACHmC,EAAAA,sBADmCvE,IA5BzCyB,EAAAX,WAoCEW,OA3CJA,EAyCOgD,MAAA,IAAAC,MAAA,qBAAA,CAAAb,QAAApC,EAAAX,kBACLW,EAAKlC,aAAAA,KAAiB4D,WAEpB1B,IAAIyD,EAAmB,CACvBC,SAAAxE,SAAAc,EAAAV,gBACDqE,SAAAzE,SAAAc,EAAAZ,gBAeCwE,SAAU1E,SAASc,EAAKT,gBAb1BsE,OAAUrE,EAAAA,aACRQ,UAAKR,GAGP,OAAKQ,EAAKX,YACRW,IAAKgD,QAAwCZ,EAASpC,qBAAtDA,EAAAW,OAAAmD,mBAAA9D,EAAAX,WAAAoE,GAAAN,KAAAnD,EAAA+D,4BAAA,MACK9C,EAAAA,2BACL,MACD,IAAA,MAiBGU,EAAW,mBAfT8B,EAAAA,OAAAA,WAAoBzD,EAAAX,WAAAoE,GAAAN,KAAAnD,EAAA+D,4BAApBN,MACMvE,EAAAA,2BACVyE,MACAC,QACAC,EAAaG,4BACbjB,EAAAA,OAAUkB,mBAAAjE,EAAAX,WAAAoE,GAAAN,KAAAnD,EAAA+D,4BAAVhB,MALF/C,EAAAkE,8BAaIlE,EAAAoD,wBAAA,WAgBNpD,EAAKW,OAAOwD,MAAMnE,EAAKN,SAfnBM,EAAAW,OAAKqB,WAALhC,EAAAH,eACE8B,EAAAA,aAAWe,KAAA,YAmBnB1C,EAAKuD,gBAAkB,WAfjBzF,EAAAsG,kBAAA,2BAAApE,EAAAhB,UAIEgB,EAAA+D,2BAAA,WAfJ/D,EAAAiB,aAAAyB,KAAA,cAiBDV,WAAAhC,EAAAqE,iBAAAnF,SAAAc,EAAAR,yBAGHQ,EAAKoD,oBAAAA,SAA0BjB,GACzBA,EAACxB,QACLX,EAAYgC,kBAAgBnC,uBAA5BsC,EAAAS,SAFF9E,EAAAsG,kBAAA,uBAAAE,KAAAC,UAAApC,IAMKoB,EAAAA,OAAAA,EAA8BiB,cAAAC,SAAAtC,EAAAuC,QACjC5G,EAAAA,aAAiBsG,KAAAA,YAIjBpE,EAAAA,uBAAuB,SAAvBmC,GACAH,EAAAA,YAFFhC,EAAAgD,MAAAb,GAMMA,EAAIS,QACN9E,EAAiBsG,kBAAkB,0BAA4BjC,EAACS,SAEhE9E,EAAiBsG,kBAAkB,0BAAyBE,KAAKC,UAALpC,IAE1DA,EAAIuC,OAAS5G,EAAiB0G,cAAcC,SAAStC,EAAIuC,QAC3D1E,EAAKiB,aAAayB,KAAK,UAI3B1C,EAAKqD,0BAAyB,SAAAlB,GACxBnC,EAAK2E,YACP3E,EAAKgD,MAAMb,GAGTA,EAAIS,QACN9E,EAAiBsG,kBAAkB,6BAA+BjC,EAACS,SAEnE9E,EAAiBsG,kBAAkB,6BAA4BE,KAAKC,UAALpC,IAkBjEnC,EAAKiB,aAAayB,KAAK,UAbtB1C,EAAAqE,iBAAA,WAkBqC,WAAlCrE,EAAKmB,mBAAmBW,OAf1BH,EAACuC,qBAA4BlE,EAAUmC,SACzCrE,EAAAsG,kBAAqB,4BACnBpE,EAAKgD,OAAMb,MAAXnC,EAAAN,SACDM,EAAAW,OAAAqB,WAAA9C,SAAAc,EAAAH,gBAiBCG,EAAKW,OAAOiE,MAAMC,GAAG,QAAS7E,EAAK8E,eAfrC9E,EAAOiB,aAAUyB,KAAA,aAAjBf,EAEO,iCAAA3B,EAAAmB,mBAAAW,OACLhE,EAAiBsG,kBAAkB,2CAAoCG,EAALpD,mBAAlEW,OACD9B,EAAAiB,aAAAyB,KAAA,WAoBH1C,EAAK8E,cAAgB,WAhBrB9E,EAAKqE,sBACHvG,EAAAsG,kBAAA,sBACApE,EAAIA,aAAKmB,KAAAA,UAGPnB,EAAAA,GAAI,aAAcA,SAAKN,EAAvBqF,EAAAC,GACAhF,IAAI6B,EAAQG,EAAAA,oBACZ,IAAAhC,EAAKW,qBAALsE,QAAmCH,EAAAA,OAmBnCE,EAAM,IAAI/B,MAAM,qCAAuCpB,EAAMC,OAAQP,GAxBvEvB,EAOO4B,eACLD,EAAWuD,oBAAAlF,EAAAlC,EAAwCqD,WAAmBW,EAAtEiD,EAAAC,GAAA7B,KAAA,WACArF,EAAAA,SAAiBsG,KAAAA,UAAAA,CACZnD,KAAAA,kBACN2B,QAAArB,EAAAa,QAbHP,MAAAA,EAAAC,MAkCUqD,YAAanF,EAAKY,kBAAkBwE,IAAI7D,EAAI8D,aAAaC,YAxB/D3D,MAOU,SAAAQ,GACZrE,EAAAA,EAAiBsG,KARfzC,QASGV,WAHPjB,EAAAiB,aAAAyB,KAAA,WAOQb,EAAaV,WAAAA,EAAnBI,EAAAwD,EAAAC,KAKEhF,EAAA6E,GAAI7E,cAAK4B,SAAgBL,EAAAwD,EAAAC,GACvBjH,IAAAA,EAAAA,EAAeoD,oBACgB,IAC3BoE,EAAAA,qBAAMN,QADqBpD,EAAAC,OAE3Bc,EAAAA,IAAAA,MAASrB,sCAFkBM,EAAAC,OAAAP,GAI3B4D,EAAAA,eAJ2BpH,EAA7BmH,oBAAAlF,EAAAlC,EAAA0H,YAAAjE,EAAAwD,EAAAC,GAAA7B,KAAA,WADFnD,EAAAyF,SAOSnB,KAAAC,UAAe,CACtBS,KAAM7C,mBARRS,QAAArB,EASWa,QACTpC,MAAKiB,EAAAA,MAVPkE,YAAAnF,EAAAY,kBAAAwE,IAAA7D,EAAA8D,aAAAC,YAC+B,MAY/BxH,SAAiB4H,GAClBV,EAAA7C,EAAAZ,KAbgC,QAclC,WAtBHvB,EAAAiB,aAAAyB,KAAA,WA6CM5E,EAAiB0H,YAAYxF,EAAMuB,EAAKwD,EAAIC,KAb5CjH,EAAAA,gBAAgBmH,SAAAA,GAIZrD,OAHF7B,EAAAA,eAAcsE,IAAI/C,EAACgD,aAAU,GAC3BgB,EAAAA,sBAAM,EAEN1D,IAAAA,QACAsD,SAAAA,EAAanF,GAJc,IAD/BA,EAAA4B,iBAQEoD,EAAM7C,SAANmC,KAAAC,UAAA,CARFgB,KAAA,kCAUMJ,YAAJnF,EAAAY,kBAAA0E,OAVFzE,eAAAb,EAAAa,eAAAuE,IAAA7D,EAAA8D,aAYK7C,qBAAAxC,EAAAwC,qBACL1E,YAAiB0H,EAAAA,eApBvBzH,EAAA0E,oBAAAzC,IA0CYA,EAAKiB,aAAayB,KAAK,UAf5BF,IAEL,MAAWmD,GAEHC,EAAAzD,OAKEtB,EAAAA,eACA2B,EAAAA,gBA9be,GA0bYxC,EAAA6E,GAAA,YAA7B,WAuBR7E,EAAKiB,aAAayB,KAAK,WAbd1C,EAAA6E,GAAA,mBAAA,SAAAtD,EAAAwD,EAAAC,GACF,GAAA7G,EAAA0H,iBAAAtE,GAiBL,MAAM,IAAI0B,MAAM,gCAdZ2C,EAAArF,cAAA,gCAAA+D,KAAAC,UAAAhD,EAAAa,UACDtE,EAAAgI,mBAAA9F,EAAAuB,GAnBLwD,EAAAxD,GAuCEyD,EAAM,IAAI/B,MAAM,gCAAiC1B,GAfrDvB,EAAK+F,cAAgBtH,4CAArBuB,EAAAmB,mBAAAW,OAEA9B,EAAAiB,aAAAyB,KAAqB,WAIrB1C,EAAK6E,GAAG,QAAA,SAARmB,GACEhG,EAAI7B,eAAS0H,EACXlE,EAAM,qBAAU3B,EAAAiG,MACjBjG,EAAAiB,aAAAyB,KAAA,QAgBDf,EAAW,cAAgB3B,EAAKiG,MAdhCnI,EAAAA,OAgBMkC,EAAKW,OAAOuF,OAfdpI,EAAAA,OAAAA,MAAiBgI,SAAAA,GAEdnE,EADLQ,EACK,gCAAAnC,EAAAiG,KAEN,0BAAAjG,EAAAiG,MACDnI,OAIG+G,EAAY,yBAAgB7E,EAAAiG,MAC3BD,MAGJrE,EAAW,4BAAX3B,EAAAiG,MAiBED,OAZMrE,EAAAA,mBAAW,GAEXA,EAAAA,kBAAW,SAAAwE,GACZnG,EAAAoG,mBAAAD,EAAAE,IAAAF,EAkB6C,IAAhDG,OAAOC,KAAKvG,EAAKoG,oBAAoBd,SAjBnCU,EAAAA,eAAI,EACLhG,EAPDiB,aAAAyB,KAAA,OAQD1C,EATDiB,aASOyB,KAAA,UAIR1C,EAdDwG,sCAcO,SAAAR,GACK,IAAVrE,OAAAA,KAAW3B,EAAAoG,oBAAAd,QACXU,EAAIvF,eAAA,EACLT,EAAAW,QAAA,YAAAX,EAAAmB,mBAAAW,OAGH9B,EAAAW,OAAAuF,OAiBQlG,EAAKW,OAAOgC,MAAM,WAhBrByD,EAAAA,aAAL1D,KAAA,QAkBUsD,OAXNhG,EAAKiB,aAAayB,KAAK,QACxBsD,MAGCA,KAGAhG,EAAAyG,oBAAuB,SAACtF,EAAmBW,UACzC9B,EAAQoG,mBAAgBD,EAAAE,IACtBrG,EAAAA,cACEA,IAEDA,EAHDwG,sCAAAR,MAUFA,EAAAA,UAAIZ,IAAA,uBAAAzH,EAAA+I,KAAAC,gBAAA,eAAA,SAAAC,EAAAC,GACLjJ,QAAA,cACIkJ,OAAA3D,KAAA,SAAA4D,GACLf,EAAAA,KAAIe,KADL,MAEA,SAAA5E,GAnBH0E,EAAAG,KAAA,CAAA7E,EAAAS,UAwCE9E,EAAiByC,cAAc4B,EAAIS","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n\n    this.unit_id = parseInt(config.unit_id) || defaultUnitId\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.unit_id = defaultUnitId\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.unit_id = defaultUnitId\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (state.matches('init')) {\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        node.serialSendingAllowed = true\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        node.stateService.send('SEND')\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        node.serialSendingAllowed = true\n        node.emit('mbopen')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          if (node.reconnectTimeout <= 0) {\n            node.reconnectTimeout = reconnectTimeMS\n          }\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        node.serialSendingAllowed = false\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n          verboseLog('connection close sent')\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TPC-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id serial (1..247)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), { payload: node.serialPort })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        const serialPortOptions = {\n          baudRate: parseInt(node.serialBaudrate),\n          dataBits: parseInt(node.serialDatabits),\n          stopBits: parseInt(node.serialStopbits),\n          parity: node.serialParity,\n          autoOpen: false\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      node.serialSendingAllowed = true\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('close', function (done) {\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + node.name)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + node.name)\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + node.name)\n            } else {\n              verboseLog('Connection closed well ' + node.name)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + node.name)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + node.name)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (modbusNode) {\n      node.registeredNodeList[modbusNode.id] = modbusNode\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.stateService.send('STOP')\n              done()\n            })\n          } else {\n            node.stateService.send('STOP')\n            done()\n          }\n        } else {\n          node.stateService.send('STOP')\n          done()\n        }\n      } else {\n        done()\n      }\n    }\n\n    node.deregisterForModbus = function (modbusNode, done) {\n      delete node.registeredNodeList[modbusNode.id]\n      if (node.closingModbus) {\n        done()\n      } else {\n        node.closeConnectionWithoutRegisteredNodes(done)\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}