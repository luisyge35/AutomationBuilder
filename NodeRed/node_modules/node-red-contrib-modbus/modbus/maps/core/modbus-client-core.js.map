{"version":3,"sources":["core/modbus-client-core.js"],"names":["require","install","de","biancoroyal","modbus","core","client","internalDebug","internalDebugFSM","modbusSerialDebug","XStateFSM","stateLogEnabled","networkErrors","this","id","states","on","INIT","BREAK","STOP","broken","createStateMachineService","ACTIVATE","RECONNECT","reconnecting","createMachine","initial","OPENSERIAL","CONNECT","FAILURE","CLOSE","QUEUE","SEND","READ","WRITE","opened","NEW","getActualUnitId","node","msg","payload","unitid","parseInt","queueUnitId","unit_id","startStateService","toggleMachine","interpret","start","activated","checkUnitId","clientType","getLogFunction","internalDebugLog","activateSendingOnSuccess","cb","cberr","resp","EMPTY","then","err","stateService","send","activateSendingOnFailure","readModbusByFunctionCodeOne","address","quantity","coreClient","modbusErrorHandling","readModbusByFunctionCodeTwo","readDiscreteInputs","writing","readModbusByFunctionCodeThree","readHoldingRegisters","closed","readModbusByFunctionCodeFour","readInputRegisters","failed","stopped","readModbusByFunctionCode","fc","readModbus","bufferCommands","queueLog","JSON","stringify","info","timeout","getTimeout","state","actualServiceState","value","activateSending","setUnitIdFromPayload","setTimeout","clientTimeout","nodeLog","message","writeRegister","writeModbusByFunctionCodeSixteen","length","Error","writeRegisters","writeModbus","clienttype","writeModbusByFunctionCodeFifteen","writeCoil","tcpHost","tcpPort","tcpType","setNewSerialNodeSettings","serialPort","serialBaudrate","serialStopbits","serialType","serialConnectionDelay","unitId","commandDelay","reconnectTimeout","setNewNodeSettings","connectorType","toUpperCase","setNewTCPNodeSettings","module","exports"],"mappings":"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","file":"../../core/modbus-client-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || { biancoroyal: { modbus: { core: { client: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.internalDebug = de.biancoroyal.modbus.core.client.internalDebug || require('debug')('contribModbus:core:client') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.internalDebugFSM = de.biancoroyal.modbus.core.client.internalDebugFSM || require('debug')('contribModbus:core:client:fsm') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.modbusSerialDebug = de.biancoroyal.modbus.core.client.modbusSerialDebug || require('debug')('modbus-serial') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.XStateFSM = de.biancoroyal.modbus.core.client.XStateFSM || require('@xstate/fsm') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.stateLogEnabled = de.biancoroyal.modbus.core.client.stateLogEnabled || false // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.core.client.networkErrors = ['ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNRESET', 'ENETRESET',\n  'ECONNABORTED', 'ECONNREFUSED', 'ENETUNREACH', 'ENOTCONN',\n  'ESHUTDOWN', 'EHOSTDOWN', 'ENETDOWN', 'EWOULDBLOCK', 'EAGAIN', 'EHOSTUNREACH']\n\nde.biancoroyal.modbus.core.client.createStateMachineService = function () {\n  this.stateLogEnabled = false\n\n  // failure is a general gate point in states to jump between states\n  return this.XStateFSM.createMachine({\n    id: 'modbus',\n    initial: 'new',\n    states: {\n      new: {\n        on: { INIT: 'init', BREAK: 'broken', STOP: 'stopped' }\n      },\n      broken: {\n        on: { INIT: 'init', STOP: 'stopped', FAILURE: 'failed', ACTIVATE: 'activated', RECONNECT: 'reconnecting' }\n      },\n      reconnecting: {\n        on: { INIT: 'init', STOP: 'stopped' }\n      },\n      init: {\n        on: { OPENSERIAL: 'opened', CONNECT: 'connected', BREAK: 'broken', FAILURE: 'failed', STOP: 'stopped' }\n      },\n      opened: {\n        on: { CONNECT: 'connected', BREAK: 'broken', FAILURE: 'failed', CLOSE: 'closed', STOP: 'stopped' }\n      },\n      connected: {\n        on: { CLOSE: 'closed', ACTIVATE: 'activated', QUEUE: 'queueing', BREAK: 'broken', FAILURE: 'failed', STOP: 'stopped' }\n      },\n      activated: {\n        on: {\n          READ: 'reading',\n          WRITE: 'writing',\n          QUEUE: 'queueing',\n          BREAK: 'broken',\n          CLOSE: 'closed',\n          FAILURE: 'failed',\n          STOP: 'stopped'\n        }\n      },\n      queueing: {\n        on: {\n          ACTIVATE: 'activated',\n          SEND: 'sending',\n          READ: 'reading',\n          WRITE: 'writing',\n          EMPTY: 'empty',\n          BREAK: 'broken',\n          CLOSE: 'closed',\n          FAILURE: 'failed',\n          STOP: 'stopped'\n        }\n      },\n      empty: { on: { QUEUE: 'queueing', BREAK: 'broken', FAILURE: 'failed', CLOSE: 'closed', STOP: 'stopped' } },\n      sending: { on: { ACTIVATE: 'activated', READ: 'reading', WRITE: 'writing', BREAK: 'broken', FAILURE: 'failed', STOP: 'stopped' } },\n      reading: { on: { ACTIVATE: 'activated', BREAK: 'broken', FAILURE: 'failed', STOP: 'stopped' } },\n      writing: { on: { ACTIVATE: 'activated', BREAK: 'broken', FAILURE: 'failed', STOP: 'stopped' } },\n      closed: { on: { FAILURE: 'failed', BREAK: 'broken', CONNECT: 'connected', RECONNECT: 'reconnecting', INIT: 'init', STOP: 'stopped' } },\n      failed: { on: { CLOSE: 'closed', BREAK: 'broken', STOP: 'stopped' } },\n      stopped: { on: { NEW: 'new', STOP: 'stopped' } }\n    }\n  })\n}\n\nde.biancoroyal.modbus.core.client.getActualUnitId = function (node, msg) {\n  return parseInt(msg.payload.unitid) || parseInt(msg.queueUnitId) || parseInt(node.unit_id)\n}\n\nde.biancoroyal.modbus.core.client.startStateService = function (toggleMachine) {\n  return this.XStateFSM.interpret(toggleMachine).start()\n}\n\nde.biancoroyal.modbus.core.client.checkUnitId = function (unitid, clientType) {\n  if (clientType === 'tcp') {\n    return unitid >= 0 && unitid <= 255\n  } else {\n    return unitid >= 1 && unitid <= 247\n  }\n}\n\nde.biancoroyal.modbus.core.client.getLogFunction = function (node) {\n  if (node.internalDebugLog) {\n    return node.internalDebugLog\n  } else {\n    return de.biancoroyal.modbus.core.client.internalDebug\n  }\n}\n\nde.biancoroyal.modbus.core.client.activateSendingOnSuccess = function (node, cb, cberr, resp, msg) {\n  node.activateSending(msg).then(function () {\n    cb(resp, msg)\n  }).catch(function (err) {\n    cberr(err, msg)\n  }).finally(function () {\n    node.stateService.send('ACTIVATE')\n  })\n}\n\nde.biancoroyal.modbus.core.client.activateSendingOnFailure = function (node, cberr, err, msg) {\n  node.activateSending(msg).then(function () {\n    cberr(err, msg)\n  }).catch(function (err) {\n    cberr(err, msg)\n  }).finally(function () {\n    node.stateService.send('ACTIVATE')\n  })\n}\n\nde.biancoroyal.modbus.core.client.readModbusByFunctionCodeOne = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  node.client.readCoils(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.readModbusByFunctionCodeTwo = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  node.client.readDiscreteInputs(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.readModbusByFunctionCodeThree = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  node.client.readHoldingRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.readModbusByFunctionCodeFour = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  node.client.readInputRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.readModbusByFunctionCode = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  const nodeLog = de.biancoroyal.modbus.core.client.getLogFunction(node)\n\n  switch (parseInt(msg.payload.fc)) {\n    case 1:\n      coreClient.readModbusByFunctionCodeOne(node, msg, cb, cberr)\n      break\n    case 2:\n      coreClient.readModbusByFunctionCodeTwo(node, msg, cb, cberr)\n      break\n    case 3:\n      coreClient.readModbusByFunctionCodeThree(node, msg, cb, cberr)\n      break\n    case 4:\n      coreClient.readModbusByFunctionCodeFour(node, msg, cb, cberr)\n      break\n    default:\n      coreClient.activateSendingOnFailure(node, cberr, new Error('Function Code Unknown'), msg)\n      nodeLog('Function Code Unknown %s', msg.payload.fc)\n      break\n  }\n}\n\nde.biancoroyal.modbus.core.client.readModbus = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  const nodeLog = de.biancoroyal.modbus.core.client.getLogFunction(node)\n\n  if (!node.client) {\n    nodeLog('Client Not Ready As Object On Reading Modbus')\n    return\n  }\n\n  if (!node.bufferCommands) {\n    if (node.clienttype !== 'tcp') {\n      node.stateService.send('READ')\n    }\n  } else {\n    node.queueLog(JSON.stringify({\n      info: 'read msg via Modbus',\n      message: msg.payload,\n      queueUnitId: msg.queueUnitId,\n      timeout: node.client.getTimeout(),\n      state: node.actualServiceState.value\n    }))\n  }\n\n  node.setUnitIdFromPayload(msg)\n  node.client.setTimeout(node.clientTimeout)\n\n  try {\n    coreClient.readModbusByFunctionCode(node, msg, cb, cberr)\n  } catch (err) {\n    nodeLog(err.message)\n    node.modbusErrorHandling(err)\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n  }\n}\n\nde.biancoroyal.modbus.core.client.writeModbusByFunctionCodeFive = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  if (msg.payload.value) {\n    msg.payload.value = true\n  } else {\n    msg.payload.value = false\n  }\n  node.client.writeCoil(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.writeModbusByFunctionCodeFifteen = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n    coreClient.activateSendingOnFailure(node, cberr, new Error('Quantity should be less or equal to coil payload array length: ' +\n      msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n  } else {\n    node.client.writeCoils(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n      coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n    }).catch(function (err) {\n      coreClient.activateSendingOnFailure(node, cberr, err, msg)\n      node.modbusErrorHandling(err)\n    })\n  }\n}\n\nde.biancoroyal.modbus.core.client.writeModbusByFunctionCodeSix = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  node.client.writeRegister(parseInt(msg.payload.address), parseInt(msg.payload.value)).then(function (resp) {\n    coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n  }).catch(function (err) {\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  })\n}\n\nde.biancoroyal.modbus.core.client.writeModbusByFunctionCodeSixteen = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n    coreClient.activateSendingOnFailure(node, cberr, new Error('Quantity should be less or equal to register payload array length: ' +\n      msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n  } else {\n    node.client.writeRegisters(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n      coreClient.activateSendingOnSuccess(node, cb, cberr, resp, msg)\n    }).catch(function (err) {\n      coreClient.activateSendingOnFailure(node, cberr, err, msg)\n      node.modbusErrorHandling(err)\n    })\n  }\n}\n\nde.biancoroyal.modbus.core.client.writeModbus = function (node, msg, cb, cberr) {\n  const coreClient = de.biancoroyal.modbus.core.client\n  const nodeLog = de.biancoroyal.modbus.core.client.getLogFunction(node)\n\n  if (!node.client) {\n    nodeLog('Client Not Ready As Object On Writing Modbus')\n    return\n  }\n\n  if (!node.bufferCommands) {\n    if (node.clienttype !== 'tcp') {\n      node.stateService.send('WRITE')\n    }\n  } else {\n    node.queueLog(JSON.stringify({\n      info: 'write msg',\n      message: msg.payload,\n      queueUnitId: msg.queueUnitId,\n      timeout: node.client.getTimeout(),\n      state: node.actualServiceState.value\n    }))\n  }\n\n  node.setUnitIdFromPayload(msg)\n  node.client.setTimeout(node.clientTimeout)\n\n  try {\n    switch (parseInt(msg.payload.fc)) {\n      case 15: // FC: 15\n        coreClient.writeModbusByFunctionCodeFifteen(node, msg, cb, cberr)\n        break\n      case 5: // FC: 5\n        coreClient.writeModbusByFunctionCodeFive(node, msg, cb, cberr)\n        break\n      case 16: // FC: 16\n        coreClient.writeModbusByFunctionCodeSixteen(node, msg, cb, cberr)\n        break\n      case 6: // FC: 6\n        coreClient.writeModbusByFunctionCodeSix(node, msg, cb, cberr)\n        break\n      default:\n        coreClient.activateSendingOnFailure(node, cberr, new Error('Function Code Unknown'), msg)\n        nodeLog('Function Code Unknown %s', msg.payload.fc)\n        break\n    }\n  } catch (err) {\n    nodeLog(err.message)\n    coreClient.activateSendingOnFailure(node, cberr, err, msg)\n    node.modbusErrorHandling(err)\n  }\n}\n\nde.biancoroyal.modbus.core.client.setNewTCPNodeSettings = function (node, msg) {\n  node.tcpHost = msg.payload.tcpHost || node.tcpHost\n  node.tcpPort = msg.payload.tcpPort || node.tcpPort\n  node.tcpType = msg.payload.tcpType || node.tcpType\n}\n\nde.biancoroyal.modbus.core.client.setNewSerialNodeSettings = function (node, msg) {\n  if (msg.payload.serialPort) {\n    node.serialPort = msg.payload.serialPort || node.serialPort\n  }\n\n  if (msg.payload.serialBaudrate) {\n    node.serialBaudrate = parseInt(msg.payload.serialBaudrate) || node.serialBaudrate\n  }\n\n  node.serialDatabits = msg.payload.serialDatabits || node.serialDatabits\n  node.serialStopbits = msg.payload.serialStopbits || node.serialStopbits\n  node.serialParity = msg.payload.serialParity || node.serialParity\n  node.serialType = msg.payload.serialType || node.serialType\n\n  if (msg.payload.serialConnectionDelay) {\n    node.serialConnectionDelay = parseInt(msg.payload.serialConnectionDelay) || node.serialConnectionDelay\n  }\n}\n\nde.biancoroyal.modbus.core.client.setNewNodeOptionalSettings = function (node, msg) {\n  if (msg.payload.unitId) {\n    node.unit_id = parseInt(msg.payload.unitId) || node.unit_id\n  }\n\n  if (msg.payload.commandDelay) {\n    node.commandDelay = parseInt(msg.payload.commandDelay) || node.commandDelay\n  }\n\n  if (msg.payload.clientTimeout) {\n    node.clientTimeout = parseInt(msg.payload.clientTimeout) || node.clientTimeout\n  }\n\n  if (msg.payload.reconnectTimeout) {\n    node.reconnectTimeout = parseInt(msg.payload.reconnectTimeout) || node.reconnectTimeout\n  }\n}\n\nde.biancoroyal.modbus.core.client.setNewNodeSettings = function (node, msg) {\n  const nodeLog = de.biancoroyal.modbus.core.client.getLogFunction(node)\n  const coreClient = de.biancoroyal.modbus.core.client\n\n  if (!msg) {\n    nodeLog('New Connection message invalid.')\n    return false\n  }\n\n  switch (msg.payload.connectorType.toUpperCase()) {\n    case 'TCP':\n      coreClient.setNewTCPNodeSettings(node, msg)\n      nodeLog('New Connection TCP Settings ' + node.tcpHost + ' ' + node.tcpPort + ' ' + node.tcpType)\n      break\n\n    case 'SERIAL':\n      coreClient.setNewSerialNodeSettings(node, msg)\n      nodeLog('New Connection Serial Settings ' + node.serialPort + ' ' + node.serialBaudrate + ' ' + node.serialType)\n      break\n\n    default:\n      nodeLog('Unknown Dynamic Reconnect Type ' + msg.payload.connectorType)\n  }\n\n  coreClient.setNewNodeOptionalSettings(node, msg)\n\n  return true\n}\n\nde.biancoroyal.modbus.core.client.messagesAllowedStates = ['activated', 'queueing', 'sending', 'empty', 'connected']\n\nmodule.exports = de.biancoroyal.modbus.core.client\n"]}