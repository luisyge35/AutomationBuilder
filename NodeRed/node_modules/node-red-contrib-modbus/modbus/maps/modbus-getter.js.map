{"version":3,"sources":["modbus-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","modbusClient","deregisterForModbus","config","nodes","createNode","this","name","unitid","internalDebugLog","adr","quantity","ModbusGetter","showStatusActivities","dataType","showErrors","getNode","ioFile","msgThruput","connection","logIOActivities","useIOForPayload","node","verboseLogging","settings","mbBasics","setNodeStatusTo","server","registerForModbus","initModbusClientEvents","resp","msg","data","onModbusCommandError","err","buildMessageWithIO","error","emptyMsgOnFail","getOriginalMessage","bufferMessageList","buildNewMessageObject","fc","setModbusError","newMsg","payload","value","Object","topic","messageId","invalidPayloadIn","client","getObjectId","emit","onModbusCommandDone","actualServiceState","on","clear","done"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,sBAIMG,EAAWH,QAAQ,yBAHzBA,EAAQA,QAAsBC,QAAtBD,CAAR,wBA8FII,EAAAA,MAAAA,aAAaC,gBA7FjB,SAAyBC,GAMvBP,EAAIQ,MAAMC,WAAWC,KAAMH,GAE3BG,KAAKC,KAAOJ,EAAOI,KANrBD,KAAMN,OAAWH,EAAQW,OACzBF,KAAMG,SAAAA,EAAmBZ,SASvBS,KAAKI,IAAMP,EAAOO,IAPpBJ,KAAAK,SAASC,EAAcT,SAGrBG,KAAKC,qBAALJ,EAAAU,qBACAP,KAAKE,WAASL,EAAOK,WAErBF,KAAKQ,WAAWX,EAAOW,WACvBR,KAAKI,WAAaA,KAGlBJ,KAAKO,UAAAA,EAAAA,UACLP,KAAKS,OAAAA,EAAaZ,MAAMa,QAACD,EAAzBE,QACAX,KAAKY,gBAAaf,EAAOe,gBACzBZ,KAAKa,gBAALhB,EAAAiB,gBAGAd,KAAKW,eAAab,EAAMY,eACxBV,KAAKe,iBAAkBlB,EACvBG,KAAKc,eAALxB,EAAuBO,SAAOiB,QAG9B,IAAKX,EAAAA,KACLa,EAAKC,kBAAoB,IAACC,IAE1BC,EAAUC,gBAAV,UAAAJ,GAEAG,IAAAA,EAASC,EAAgBtB,MAAAY,QAAWM,EAApCK,QAEM1B,IAEJA,EAAA2B,kBAAAN,GACDG,EAAAI,uBAAAP,EAAArB,GACDA,EAAAA,oBAAa2B,SAAbE,EAAAC,GACAN,EAASI,sBAILJ,EAASC,gBAAgB,eAAgBJ,GAD3CA,EAAIA,KAAKT,EAAAA,mBAAsBS,EAAAQ,EAAAE,KAAAF,EAAAC,KAMjCT,EAAKW,qBAAuB,SAAUC,EAAKH,GAHzCT,EAAUtB,EAASmC,SAJrBb,EAAAP,YAUIO,EAAKc,MAAMF,EAAKH,GAGlBN,EAASY,eAAef,EAAMY,EAAKH,GAJnCN,EAASV,eAAYO,EAAArB,EAAAiC,EAAAnC,EAAAuC,mBAAAhB,EAAAiB,kBAAAR,KAQvBT,EAAKkB,sBAAwB,SAAUlB,EAAMS,GAJ3CN,IAAAA,EAASY,OAAAA,OAAT,GAAAN,GAUEU,OATFhB,EAAAA,MAASiB,EAAAA,OAATpB,EAA8BrB,GAPhC0C,EAAAC,QAAA,CAcIC,MAAOd,EAAIa,QAAQC,OAASd,EAAIa,QAJhCpC,OAACgC,EAAAA,OACHC,GAAME,EAASG,uBAAfxB,EAAAR,UACA6B,QAAOI,EAAQhB,IACfY,SAAOC,EAAUjC,SACfkC,UAAWD,EAAAA,WAEP7C,GAGJiD,EAAAA,GAAAA,QAAWjB,SAAIiB,GANjBvB,EAAAwB,iBAAAlB,IAWF9B,EAAiBiD,SASfnB,EAAIiB,UAAYjD,EAAOoD,cAJvB7B,EAAKrB,kBAAaiD,IAAQnB,EAAAiB,UAAAjB,GACxBA,EAAAT,EAAAkB,sBAAAlB,EAAAS,GACD9B,EAAAmD,KAAA,aAAArB,EAAAT,EAAA+B,oBAAA/B,EAAAW,sBAEGe,EAAAA,sBACJ1B,EAAKiB,gBAAsBR,EAA3BuB,mBAAAhC,MAIAA,EAAAiC,GAAIjC,QAAKT,SAAAA,GACPY,EAAAA,gBAASC,SAAgBzB,GAC1BqB,EAAAiB,kBAAAiB,QAhBHvD,EAAAC,oBAAAoB,EAAAmC","file":"../modbus-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus Getter node.\n * @module NodeRedModbusGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:getter')\n\n  function ModbusGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.msgThruput = config.msgThruput\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusCommandDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n    }\n\n    node.onModbusCommandError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      mbBasics.emptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const newMsg = Object.assign({}, msg)\n      newMsg.topic = msg.topic || node.id\n      newMsg.payload = {\n        value: msg.payload.value || msg.payload,\n        unitid: node.unitid,\n        fc: mbCore.functionCodeModbusRead(node.dataType),\n        address: node.adr,\n        quantity: node.quantity,\n        messageId: msg.messageId\n      }\n      return newMsg\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      msg.messageId = mbCore.getObjectId()\n      node.bufferMessageList.set(msg.messageId, msg)\n      msg = node.buildNewMessageObject(node, msg)\n      modbusClient.emit('readModbus', msg, node.onModbusCommandDone, node.onModbusCommandError)\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-getter', ModbusGetter)\n}\n"]}