"use strict";module.exports=function(c){require("source-map-support").install();var l=require("./modbus-basics"),u=require("./core/modbus-client-core"),d=require("./core/modbus-queue-core");c.nodes.registerType("modbus-client",function(e){c.nodes.createNode(this,e);var t=require("modbus-serial"),n=500,i=2e3,o=" Get More About It By Logging";this.clienttype=e.clienttype,void 0===e.parallelUnitIdsAllowed?this.bufferCommands=!0:this.bufferCommands=e.bufferCommands,this.queueLogEnabled=e.queueLogEnabled,this.stateLogEnabled=e.stateLogEnabled,this.tcpHost=e.tcpHost,this.tcpPort=parseInt(e.tcpPort)||502,this.tcpType=e.tcpType,this.serialPort=e.serialPort,this.serialBaudrate=e.serialBaudrate,this.serialDatabits=e.serialDatabits,this.serialStopbits=e.serialStopbits,this.serialParity=e.serialParity,this.serialType=e.serialType,this.serialConnectionDelay=parseInt(e.serialConnectionDelay)||n,this.unit_id=parseInt(e.unit_id)||1,this.commandDelay=parseInt(e.commandDelay)||1,this.clientTimeout=parseInt(e.clientTimeout)||1e3,this.reconnectTimeout=parseInt(e.reconnectTimeout)||i,this.reconnectOnTimeout=e.reconnectOnTimeout,void 0===e.parallelUnitIdsAllowed?this.parallelUnitIdsAllowed=!0:this.parallelUnitIdsAllowed=e.parallelUnitIdsAllowed;var r=this;function s(e){c.settings.verbose&&r.warn("Client -> "+e+r.serverInfo)}function a(e){c.settings.verbose&&u.internalDebug("Client -> "+e+r.serverInfo)}r.isFirstInitOfConnection=!0,r.closingModbus=!1,r.client=null,r.bufferCommandList=new Map,r.sendingAllowed=new Map,r.unitSendingAllowed=[],r.messageAllowedStates=u.messagesAllowedStates,r.serverInfo="",r.stateMachine=null,r.stateService=null,r.stateMachine=u.createStateMachineService(),r.actualServiceState=r.stateMachine.initialState,r.actualServiceStateBefore=r.actualServiceState,r.stateService=u.startStateService(r.stateMachine),r.reconnectTimeoutId=0,r.serialSendingAllowed=!1,r.setUnitIdFromPayload=function(e){var t=u.getActualUnitId(r,e);u.checkUnitId(t,r.clienttype)||(r.unit_id=1),r.client.setID(t),e.unitId=t},!Number.isNaN(r.unit_id)&&u.checkUnitId(r.unit_id,r.clienttype)||(r.unit_id=1),r.updateServerinfo=function(){"tcp"===r.clienttype?r.serverInfo=" TCP@"+r.tcpHost+":"+r.tcpPort:r.serverInfo=" Serial@"+r.serialPort+":"+r.serialBaudrate+"bit/s",r.serverInfo+=" default Unit-Id: "+r.unit_id},r.queueLog=function(e){r.bufferCommands&&r.queueLogEnabled&&a(e)},r.stateService.subscribe(function(e){var t;if(r.actualServiceStateBefore=r.actualServiceState,r.actualServiceState=e,t=e.value,r.stateLogEnabled&&a(t),e.matches("init")){r.updateServerinfo(),d.initQueue(r),r.reconnectTimeoutId=0;try{r.isFirstInitOfConnection?(r.isFirstInitOfConnection=!1,s("init in 500 ms"),setTimeout(r.connectClient,n)):(s("init in "+r.reconnectTimeout+" ms"),setTimeout(r.connectClient,r.reconnectTimeout))}catch(e){r.error(e,{payload:"client connection error "+o})}r.emit("mbinit")}e.matches("connected")&&(r.serialSendingAllowed=!0,r.emit("mbconnected")),e.matches("activated")&&(r.emit("mbactive"),r.bufferCommands&&!d.checkQueuesAreEmpty(r)&&r.stateService.send("QUEUE")),e.matches("queueing")&&(r.stateService.send("SEND"),setTimeout(function(){d.dequeueCommand(r)},r.commandDelay),r.emit("mbqueue")),e.matches("opened")&&(r.serialSendingAllowed=!0,r.emit("mbopen")),e.matches("closed")&&(r.emit("mbclosed"),r.stateService.send("RECONNECT")),e.matches("stopped")&&(s("stopped state without reconnecting"),r.emit("mbclosed")),e.matches("failed")&&(r.emit("mberror","Modbus Failure On State "+r.actualServiceStateBefore.value+o),r.stateService.send("BREAK")),e.matches("broken")&&(r.emit("mbbroken","Modbus Broken On State "+r.actualServiceStateBefore.value+o),r.reconnectOnTimeout?(r.reconnectTimeout<=0&&(r.reconnectTimeout=i),r.stateService.send("RECONNECT")):r.stateService.send("ACTIVATE")),e.matches("reconnecting")&&(r.serialSendingAllowed=!1,r.emit("mbreconnecting"),r.reconnectTimeout<=0&&(r.reconnectTimeout=i),setTimeout(function(){r.reconnectTimeoutId=0,r.stateService.send("INIT")},r.reconnectTimeout))}),r.connectClient=function(){if(r.client)try{r.client.close(function(){a("connection closed")}),a("connection close sent")}catch(e){a(e.message)}if(r.client=null,r.client=new t,r.clientTimeout||(r.clientTimeout=1e3),r.reconnectTimeout||(r.reconnectTimeout=i),"tcp"===r.clienttype){if(!u.checkUnitId(r.unit_id,r.clienttype))return r.error(new Error("wrong unit-id (0..255)"),{payload:r.unit_id}),void r.stateService.send("FAILURE");switch(r.tcpType){case"C701":a("C701 port UDP bridge"),r.client.connectC701(r.tcpHost,{port:r.tcpPort,autoOpen:!0}).then(r.setTCPConnectionOptions).then(r.setTCPConnected).catch(r.modbusTcpErrorHandling);break;case"TELNET":a("Telnet port"),r.client.connectTelnet(r.tcpHost,{port:r.tcpPort,autoOpen:!0}).then(r.setTCPConnectionOptions).catch(r.modbusTcpErrorHandling);break;case"TPC-RTU-BUFFERED":a("TCP RTU buffered port"),r.client.connectTcpRTUBuffered(r.tcpHost,{port:r.tcpPort,autoOpen:!0}).then(r.setTCPConnectionOptions).catch(r.modbusTcpErrorHandling);break;default:a("TCP port"),r.client.connectTCP(r.tcpHost,{port:r.tcpPort,autoOpen:!0}).then(r.setTCPConnectionOptions).catch(r.modbusTcpErrorHandling)}}else{if(!u.checkUnitId(r.unit_id,r.clienttype))return r.error(new Error("wrong unit-id serial (1..247)"),{payload:r.unit_id}),void r.stateService.send("FAILURE");if(r.serialConnectionDelay||(r.serialConnectionDelay=n),!r.serialPort)return r.error(new Error("wrong serial port"),{payload:r.serialPort}),void r.stateService.send("FAILURE");var e={baudRate:parseInt(r.serialBaudrate),dataBits:parseInt(r.serialDatabits),stopBits:parseInt(r.serialStopbits),parity:r.serialParity,autoOpen:!1};switch(r.serialType){case"ASCII":a("ASCII port serial"),r.client.connectAsciiSerial(r.serialPort,e).then(r.setSerialConnectionOptions).catch(r.modbusSerialErrorHandling);break;case"RTU":a("RTU port serial"),r.client.connectRTU(r.serialPort,e).then(r.setSerialConnectionOptions).catch(r.modbusSerialErrorHandling);break;default:a("RTU buffered port serial"),r.client.connectRTUBuffered(r.serialPort,e).then(r.setSerialConnectionOptions).catch(r.modbusSerialErrorHandling)}}},r.setTCPConnectionOptions=function(){r.client.setID(r.unit_id),r.client.setTimeout(r.clientTimeout),r.stateService.send("CONNECT")},r.setTCPConnected=function(){u.modbusSerialDebug("modbus tcp connected on "+r.tcpHost)},r.setSerialConnectionOptions=function(){r.stateService.send("OPENSERIAL"),setTimeout(r.openSerialClient,parseInt(r.serialConnectionDelay))},r.modbusErrorHandling=function(e){e.message?u.modbusSerialDebug("modbusErrorHandling:"+e.message):u.modbusSerialDebug("modbusErrorHandling:"+JSON.stringify(e)),e.errno&&u.networkErrors.includes(e.errno)&&r.stateService.send("FAILURE")},r.modbusTcpErrorHandling=function(e){r.showErrors&&r.error(e),e.message?u.modbusSerialDebug("modbusTcpErrorHandling:"+e.message):u.modbusSerialDebug("modbusTcpErrorHandling:"+JSON.stringify(e)),e.errno&&u.networkErrors.includes(e.errno)&&r.stateService.send("BREAK")},r.modbusSerialErrorHandling=function(e){r.showErrors&&r.error(e),e.message?u.modbusSerialDebug("modbusSerialErrorHandling:"+e.message):u.modbusSerialDebug("modbusSerialErrorHandling:"+JSON.stringify(e)),r.stateService.send("BREAK")},r.openSerialClient=function(){"opened"===r.actualServiceState.value?(a("time to open Unit "+r.unit_id),u.modbusSerialDebug("modbus connection opened"),r.client.setID(r.unit_id),r.client.setTimeout(parseInt(r.clientTimeout)),r.client._port.on("close",r.onModbusClose),r.stateService.send("CONNECT")):(a("wrong state on connect serial "+r.actualServiceState.value),u.modbusSerialDebug("modbus connection not opened state is %s",r.actualServiceState.value),r.stateService.send("BREAK"))},r.onModbusClose=function(){s("Modbus closed port"),u.modbusSerialDebug("modbus closed port"),r.stateService.send("CLOSE")},r.on("readModbus",function(t,e,n){var i=r.actualServiceState;-1===r.messageAllowedStates.indexOf(i.value)?n(new Error("Client Not Ready To Read At State "+i.value),t):r.bufferCommands?d.pushToQueueByUnitId(r,u.readModbus,t,e,n).then(function(){r.queueLog(JSON.stringify({info:"queued read msg",message:t.payload,state:i.value,queueLength:r.bufferCommandList.get(t.queueUnitId).length}))}).catch(function(e){n(e,t)}).finally(function(){r.stateService.send("QUEUE")}):u.readModbus(r,t,e,n)}),r.on("writeModbus",function(t,e,n){var i=r.actualServiceState;-1===r.messageAllowedStates.indexOf(i.value)?n(new Error("Client Not Ready To Write At State "+i.value),t):r.bufferCommands?d.pushToQueueByUnitId(r,u.writeModbus,t,e,n).then(function(){r.queueLog(JSON.stringify({info:"queued write msg",message:t.payload,state:i.value,queueLength:r.bufferCommandList.get(t.queueUnitId).length}))}).catch(function(e){n(e,t)}).finally(function(){r.stateService.send("QUEUE")}):u.writeModbus(r,t,e,n)}),r.activateSending=function(n){return r.sendingAllowed.set(n.queueUnitId,!0),r.serialSendingAllowed=!0,new Promise(function(e,t){try{r.bufferCommands&&(r.queueLog(JSON.stringify({info:"queue response activate sending",queueLength:r.bufferCommandList.length,sendingAllowed:r.sendingAllowed.get(n.queueUnitId),serialSendingAllowed:r.serialSendingAllowed,queueUnitId:n.queueUnitId})),d.checkQueuesAreEmpty(r)&&r.stateService.send("EMPTY")),e()}catch(e){t(e)}})},a("initialized"),r.setMaxListeners(0),r.on("reconnect",function(){r.stateService.send("CLOSE")}),r.on("dynamicReconnect",function(e,t,n){if(l.invalidPayloadIn(e))throw new Error("Message Or Payload Not Valid");u.internalDebug("Dynamic Reconnect Parameters "+JSON.stringify(e.payload)),u.setNewNodeSettings(r,e)?t(e):n(new Error("Message Or Payload Not Valid"),e),u.internalDebug("Dynamic Reconnect Starts on actual state "+r.actualServiceState.value),r.stateService.send("CLOSE")}),r.on("close",function(t){r.closingModbus=!0,a("stop fsm on close "+r.name),r.stateService.send("STOP"),a("close node "+r.name),r.client?r.client.isOpen?r.client.close(function(e){a(e?"Connection closed with error "+r.name:"Connection closed well "+r.name),t()}):(a("connection was closed "+r.name),t()):(a("Connection closed simple "+r.name),t())}),r.registeredNodeList={},r.registerForModbus=function(e){r.registeredNodeList[e.id]=e,1===Object.keys(r.registeredNodeList).length&&(r.closingModbus=!1,r.stateService.send("NEW"),r.stateService.send("INIT"))},r.closeConnectionWithoutRegisteredNodes=function(e){0===Object.keys(r.registeredNodeList).length?(r.closingModbus=!0,r.client&&"stopped"!==r.actualServiceState.value&&r.client.isOpen?r.client.close(function(){r.stateService.send("STOP"),e()}):(r.stateService.send("STOP"),e())):e()},r.deregisterForModbus=function(e,t){delete r.registeredNodeList[e.id],r.closingModbus?t():r.closeConnectionWithoutRegisteredNodes(t)}}),c.httpAdmin.get("/modbus/serial/ports",c.auth.needsPermission("serial.read"),function(e,t){require("serialport").list().then(function(e){t.json(e)}).catch(function(e){t.json([e.message]),u.internalDebug(e.message)})})};
//# sourceMappingURL=maps/modbus-client.js.map
