{"version":3,"sources":["modbus-flex-write.js"],"names":["module","exports","RED","require","install","mbCore","internalDebugLog","nodes","registerType","config","mbBasics","createNode","this","name","showStatusActivities","emptyMsgOnFail","settings","verbose","showErrors","node","getNode","server","bufferMessageList","modbusClient","registerForModbus","onModbusWriteDone","resp","msg","payload","onModbusWriteError","err","message","error","setModbusError","getOriginalMessage","prepareMsg","fc","parseInt","unitid","address","parse","quantity","isValidModbusMsg","Number","isInteger","isValid","Object","prototype","value","call","JSON","indexOf","buildNewMessageObject","newMsg","id","messageId","on","invalidPayloadIn","client","setMsgPayloadFromHTTPRequests","getObjectId","set","emit","setNodeStatusTo","actualServiceState","clear","deregisterForModbus","done"],"mappings":"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","file":"../modbus-flex-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus flexible Write node.\n * @module NodeRedModbusFlexWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:write')\n\n  function ModbusFlexWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('writing done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      mbBasics.emptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc)\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address)\n      msg.payload.quantity = parseInt(msg.payload.quantity)\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n              (msg.payload.fc === 5 ||\n                msg.payload.fc === 6 ||\n                msg.payload.fc === 15 ||\n                msg.payload.fc === 16))) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.address) &&\n              msg.payload.address >= 0 &&\n              msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.quantity) &&\n              msg.payload.quantity >= 1 &&\n              msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.setMsgPayloadFromHTTPRequests = function (msg) {\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') && typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n      return msg\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const newMsg = Object.assign({}, msg)\n      newMsg.topic = msg.topic || node.id\n      newMsg.payload = {\n        value: msg.payload.value || msg.value,\n        unitid: msg.payload.unitid,\n        fc: msg.payload.fc,\n        address: msg.payload.address,\n        quantity: msg.payload.quantity,\n        messageId: msg.messageId\n      }\n      return newMsg\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\n        return\n      }\n\n      try {\n        msg = node.prepareMsg(msg)\n        if (node.isValidModbusMsg(msg)) {\n          msg = node.setMsgPayloadFromHTTPRequests(msg)\n          msg.messageId = mbCore.getObjectId()\n          node.bufferMessageList.set(msg.messageId, msg)\n          const newMsg = node.buildNewMessageObject(node, msg)\n          modbusClient.emit('writeModbus', newMsg, node.onModbusWriteDone, node.onModbusWriteError)\n        }\n      } catch (err) {\n        internalDebugLog(err.message)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n\n        mbBasics.emptyMsgOnFail(node, err, msg)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-write', ModbusFlexWrite)\n}\n"]}