{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","clear","sendingAllowed","unitSendingAllowed","step","bufferCommandList","set","queuesAreEmpty","get","length","sequentialDequeueCommand","Promise","resolve","reject","checkQueuesAreEmpty","parallelUnitIdsAllowed","unitId","sendQueueDataToModbus","shift","queueLog","JSON","stringify","queueCore","serialSendingAllowed","isValidUnitId","queueLength","warn","type","command","msg","cb","cberr","state","info","value","clienttype","callModbus","dequeueCommand","actualServiceState","indexOf","delay","commandDelay","dequeueLogEntry","err","message","messageAllowedStates","parseInt","unit_id","getQueueLengthByUnitId","this","pushToQueueByUnitId","coreQueue","getUnitIdToQueue","Error","queueLengthByUnitId","queueUnitId"],"mappings":"AAQA,aACAA,QAAQ,sBAAsBC,UAE9B,IAAIC,GAAKA,IAAM,CAAEC,YAAa,CAAEC,OAAQ,CAAEC,MAAO,CAAEC,KAAM,OAAzDJ,GAAAC,YAAeC,OAAAC,MAAAC,KAAAC,cAAAL,GAAAC,YAAAC,OAAAC,MAAAC,KAAAC,eAAAP,QAAA,QAAAA,CAAA,4BAAEG,GAAAA,YAAaC,OAAAC,MAAAC,KAAAA,KAAAJ,GAAAC,YAAAC,OAAAC,MAAAC,KAAAA,MAAAN,QAAA,iBAAYK,GAAAA,YAAOD,OAAAC,MAAAC,KAAAE,UAAA,SAAAC,GAAEH,EAAAA,kBAAMI,QAARD,EAAAE,eAAAD,QAATD,EAAAG,mBAAA,GAStC,IATkE,IAAAC,EAAA,EAAAA,GAAA,IAAAA,IAUhEJ,EAAKK,kBAAkBC,IAAIF,EAAM,IATlCV,EAAAA,eAAmBE,IAAMC,GAAKC,IAGjCL,GAAGC,YAAYC,OAAOC,MAAMC,KAAKE,oBAAsBC,SAAMA,GAE3DA,IADAA,IAAIO,GAACF,EACAH,EAAAA,EAALE,GAAA,IAAAA,IACAJ,GAAA,IAAKG,EAAqBE,kBAA1BG,IAAAJ,GAAAK,OAEA,OAAKF,GAGJd,GAAAC,YAAAC,OAAAC,MAAAC,KAAAa,yBAAA,SAAAV,GARH,OAAA,IAAAW,QAqBI,SAAUC,EAASC,GAVpBnB,IAAAA,EAAmBE,GAAtBF,YAAiCoB,OAAAA,MAAjCjB,KAaM,GAAIG,EAAKe,uBAXR,IAAIX,IAAIY,EAAU,EAAIA,EAAS,IAAIA,GAAA,EACtCT,EAAcU,sBAAUZ,EAALW,OAcV,CAZX,IAAOT,EAAPP,EAAAG,mBAAAe,QAeMlB,EAAKmB,SAASC,KAAKC,UAAU,CAZlC3B,KAAYC,6BACNqB,OAAAA,EAEGM,cAAe5B,EAAYC,cAAaE,GAa1CK,eAAgBF,EAAKE,eAAeM,IAAIQ,GAXxChB,qBAAKe,EAAwBQ,wBAG9BvB,EAAAuB,sBAHHD,EAIOE,cAAAR,IACCA,EAAAA,eAAcb,IAAAA,IAalBH,EAAKuB,sBAAuB,EAX1BD,EAAUF,sBAAepB,EAAAgB,IAG3BQ,EAAAA,KAAAA,2CAgBJZ,OANGnB,GAAAC,YAAMC,OAAAC,MAAAC,KAAAoB,sBAAA,SAAAjB,EAAAgB,GACL,IAAAS,EAAAzB,EAAAK,kBAAAG,IAAAQ,GAAAP,OASR,GARQT,EAAAA,SAAK0B,KAAKL,UAAA,CAEXM,KAAA,4BACFX,OAAAA,EAUHS,YAAAA,EATEb,eAAOZ,EAAAE,eAAAM,IAAAQ,GA9BXO,qBAAAvB,EAAAuB,wBAkCC7B,EAAYC,CACb,IAAM8B,EAAczB,EAAKK,kBAAkBG,IAAIQ,GAAQP,QACvDT,IAAKmB,EAIHjB,MAAAA,IAAAA,MAAgBF,6BAHhB2B,EAAMzB,eAAAI,IAAAU,GADqB,GAE3BA,EAAAA,WAF2BhB,EAAA4B,EAAAC,IAAAD,EAAAE,GAAAF,EAAAG,SAS3BtC,GAAAC,YAAaC,OAAOC,MAACS,KAAAA,gBAAL,SAAhBL,EAAAgC,EAAAC,GAWFjC,EAAKmB,SAASC,KAAKC,UAAU,CAV3BW,MAAIJ,EAASM,MACXlC,QAAKE,GAAAA,OAAAA,EAAAA,KAAAA,OAAAA,EAALiC,YACAP,MAAAA,EAAQQ,iBAIX3C,GAAAC,YAAAC,OAAAC,MAAAC,KAAAwC,eAAA,SAAArC,GAlBH,IAAAsB,EAAA7B,GAAAC,YAAAC,OAAAC,MAAAC,KA+BQmC,EAAQhC,EAAKsC,oBATU,IAAzBtC,EAACmB,qBAAwBoB,QAAAP,EAAAE,OAC3BF,EAAOA,gBADoBhC,EAAAgC,EAAA,oCAG3BQ,EAAOxC,yBAAKyC,GAAAA,KAAAA,WAHdnB,EAAAoB,gBAAA1C,EAAAgC,EAAA,0BAGEQ,MAJJ,SAAAG,GAkBMrB,EAAUoB,gBAAgB1C,EAAMgC,EAAO,yBAA2BW,EAAIC,YAN1EnD,GAAAC,YAASmD,OAAAA,MAAAA,KAAqBN,iBAA1B,SAAuDvC,EAAA6B,GACzDP,OAAAA,SAAUoB,EAAAA,QAAgB1C,SAA1B8C,SAAuC9C,EAAA+C,UAGrCzB,GAAAA,YAAS3B,OAAC+C,MAAAA,KAAgB1C,cAAa,SAAAgB,GACxC,OAAQ,GAFTA,GAESA,GAAe,KAGzBvB,GAAAC,YAAAC,OAAAC,MAAAC,KAAAmD,uBAAA,SAAAhD,EAAAgB,GAZH,GAAAiC,KAAAzB,cAAAR,GAyBI,OAAOhB,EAAKK,kBAAkBG,IAAIQ,GAAQP,OAT5C,MAAOqC,IAAAA,MAASjB,gCAAoCb,IAIpDvB,GAAAC,YAAcC,OAANC,MAAeoB,KAAMkC,oBAA7B,SAAAlD,EAAAoC,EAAAP,EAAAC,EAAAC,GADF,IAAAoB,EAAA1D,GAAAC,YAAAC,OAAAC,MAAAC,KAIE,OAACH,IAAAA,QACD,SAAS8B,EAAAA,GACP,IADF,IAEOR,EAAAmC,EAAAC,iBAAApD,EAAA6B,GACKwB,EAAMF,EAAAH,uBAAhBhD,EAAAgB,GAJJa,EAAAyB,oBAAA,CAAAtC,OAAAA,EAAAS,YAAAA,GAkBQI,EAAI0B,YAAcvC,EATlBmC,EAAY1D,wBAEXO,EAAIW,mBACCC,KAAVI,GAGIhB,EAAMyB,kBAAc0B,IAAUH,GAAAA,KAAAA,CAAAA,WAAVZ,EAApBP,IAAAA,EAAAC,GAAAA,EAAAC,MAAAA,IAEAF,EAAIyB,SAAAA,KAAAA,UAAsB,CAAEtC,KAAAA,6BAAQS,QAAWI,EAAXJ,QAApCT,OAAAA,KAaAJ,IAVA,MAAS+B,GACP3C,EAAKG,OAG2D0B,OAAAA,QAA1BpC,GAAAC,YAAAC,OAAAC,MAAAC","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\n  node.bufferCommandList.clear()\n  node.sendingAllowed.clear()\n  node.unitSendingAllowed = []\n\n  for (let step = 0; step <= 255; step++) {\n    node.bufferCommandList.set(step, [])\n    node.sendingAllowed.set(step, true)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\n  let queuesAreEmpty = true\n  for (let step = 0; step <= 255; step++) {\n    queuesAreEmpty &= (node.bufferCommandList.get(step).length === 0)\n  }\n  return queuesAreEmpty\n}\n\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\n  return new Promise(\n    function (resolve, reject) {\n      const queueCore = de.biancoroyal.modbus.queue.core\n\n      if (node.parallelUnitIdsAllowed) {\n        for (let unitId = 0; unitId < 256; unitId += 1) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        }\n      } else {\n        const unitId = node.unitSendingAllowed.shift()\n\n        node.queueLog(JSON.stringify({\n          type: 'sequential dequeue command',\n          unitId,\n          isValidUnitId: queueCore.isValidUnitId(unitId),\n          sendingAllowed: node.sendingAllowed.get(unitId),\n          serialSendingAllowed: node.serialSendingAllowed\n        }))\n\n        if (node.serialSendingAllowed &&\n          queueCore.isValidUnitId(unitId) &&\n          node.sendingAllowed.get(unitId)) {\n          node.serialSendingAllowed = false\n          queueCore.sendQueueDataToModbus(node, unitId)\n        } else {\n          // if (node.showErrors) {\n          node.warn('sequential dequeue command not possible')\n          // }\n        }\n      }\n      resolve()\n    })\n}\n\nde.biancoroyal.modbus.queue.core.sendQueueDataToModbus = function (node, unitId) {\n  const queueLength = node.bufferCommandList.get(unitId).length\n  node.queueLog(JSON.stringify({\n    type: 'send queue data to Modbus',\n    unitId,\n    queueLength,\n    sendingAllowed: node.sendingAllowed.get(unitId),\n    serialSendingAllowed: node.serialSendingAllowed\n  }))\n\n  if (queueLength) {\n    const command = node.bufferCommandList.get(unitId).shift()\n    if (command) {\n      node.sendingAllowed.set(unitId, false)\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    } else {\n      throw new Error('Command On Send Not Valid')\n    }\n  }\n}\n\nde.biancoroyal.modbus.queue.core.dequeueLogEntry = function (node, state, info) {\n  node.queueLog(JSON.stringify({\n    state: state.value,\n    message: `${info} ${node.clienttype}`,\n    delay: node.commandDelay\n  }))\n}\n\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\n  const queueCore = de.biancoroyal.modbus.queue.core\n  const state = node.actualServiceState\n\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\n    queueCore.dequeueLogEntry(node, state, 'dequeue command disallowed state')\n  } else {\n    queueCore.sequentialDequeueCommand(node).then(function () {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command done')\n    }).catch(function (err) {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command error ' + err.message)\n    })\n  }\n}\n\nde.biancoroyal.modbus.queue.core.getUnitIdToQueue = function (node, msg) {\n  return parseInt(msg.payload.unitid) || parseInt(node.unit_id)\n}\n\nde.biancoroyal.modbus.queue.core.isValidUnitId = function (unitId) {\n  return (unitId >= 0 || unitId <= 255)\n}\n\nde.biancoroyal.modbus.queue.core.getQueueLengthByUnitId = function (node, unitId) {\n  if (this.isValidUnitId(unitId)) {\n    return node.bufferCommandList.get(unitId).length\n  } else {\n    throw new Error('(0-255) Got A Wrong Unit-Id: ' + unitId)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\n  const coreQueue = de.biancoroyal.modbus.queue.core\n\n  return new Promise(\n    function (resolve, reject) {\n      try {\n        const unitId = coreQueue.getUnitIdToQueue(node, msg)\n        const queueLength = coreQueue.getQueueLengthByUnitId(node, unitId)\n\n        msg.queueLengthByUnitId = { unitId, queueLength }\n        msg.queueUnitId = unitId\n\n        if (!node.parallelUnitIdsAllowed) {\n          node.unitSendingAllowed.push(unitId)\n        }\n\n        node.bufferCommandList.get(unitId).push({ callModbus: callModbus, msg: msg, cb: cb, cberr: cberr })\n        node.queueLog(JSON.stringify({\n          info: 'pushed to Queue by Unit-Id',\n          message: msg.payload,\n          unitId\n        }))\n        resolve()\n      } catch (err) {\n        reject(err)\n      }\n    })\n}\n\nmodule.exports = de.biancoroyal.modbus.queue.core\n"]}