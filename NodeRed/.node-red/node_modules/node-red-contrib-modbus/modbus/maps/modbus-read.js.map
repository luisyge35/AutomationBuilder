{"version":3,"sources":["modbus-read.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","createNode","this","config","name","topic","unitid","dataType","adr","ModbusRead","quantity","rate","delayOnStart","parseInt","startDelayTime","rateUnit","showStatusActivities","showErrors","useIOFile","connection","getNode","ioFile","logIOActivities","internalDebugLog","node","delayTimerID","timerID","timeoutOccurred","INPUT_TIMEOUT_MILLISECONDS","statusText","mbBasics","setNodeStatusTo","modbusClient","server","values","statusValue","input","msg","statusOptions","setNodeStatusProperties","setNodeStatusWithTimeTo","search","newStatusText","status","shape","get_timeUnit_name","fill","text","registerForModbus","onModbusInit","onModbusConnect","clearTimeout","startIntervalReading","modbusPollingRead","calc_rateByUnit","onModbusActive","onModbusError","failureMsg","reconnectOnTimeout","clearInterval","warn","onModbusClose","onModbusBroken","reconnectTimeout","on","client","from","payload","address","messageId","getObjectId","emit","onModbusReadDone","onModbusReadError","resp","response","lastUpdatedAt","internalDebug","allValueNames","nameValuesFromIOFile","valueNames","filterValueNames","functionCodeModbusRead","deregisterForModbus","responseBuffer","sendMessage","origMsg","useIOForPayload","send","data","err","message","setModbusError","done","error","httpAdmin","post","auth","needsPermission","req","res","getTimeInfo","params","id","sendStatus","_","toString"],"mappings":"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","file":"../modbus-read.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:read')\n\n  function ModbusRead (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity || 1\n\n    this.rate = config.rate\n    this.rateUnit = config.rateUnit\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    let delayTimerID = null\n    let timerID = null\n    let timeoutOccurred = false\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.statusText = 'waiting'\n    mbBasics.setNodeStatusTo(node.statusText, node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusInit = function () {\n      mbBasics.setNodeStatusTo('initialize', node)\n    }\n\n    node.onModbusConnect = function () {\n      if (node.delayOnStart) {\n        if (!delayTimerID) {\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        } else {\n          clearTimeout(delayTimerID)\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        }\n      } else {\n        if (delayTimerID) {\n          clearTimeout(delayTimerID)\n        }\n        node.startIntervalReading()\n      }\n\n      setNodeStatusWithTimeTo('connected')\n    }\n\n    node.startIntervalReading = function () {\n      if (!timerID) {\n        timerID = setInterval(node.modbusPollingRead, mbBasics.calc_rateByUnit(node.rate, node.rateUnit))\n      }\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusWithTimeTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      mbBasics.setNodeStatusTo('failure', node)\n      if (modbusClient.reconnectOnTimeout) {\n        if (timerID) {\n          clearInterval(timerID) // clear Timer from events\n        }\n        timerID = null\n      }\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (timerID) {\n        clearInterval(timerID) // clear Timer from events\n      }\n      timerID = null\n    }\n\n    node.onModbusBroken = function () {\n      if (modbusClient.reconnectOnTimeout) {\n        mbBasics.setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.', node)\n        if (timerID) {\n          clearInterval(timerID) // clear Timer from events\n        }\n        timerID = null\n      }\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mbqueue', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.modbusPollingRead = function () {\n      if (!modbusClient.client) {\n        setNodeStatusWithTimeTo('waiting')\n        return\n      }\n\n      const msg = {\n        topic: node.topic || 'polling',\n        from: node.name,\n        payload: {\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusRead(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: mbCore.getObjectId()\n        }\n      }\n\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('polling')\n      }\n\n      modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n    }\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('reading done')\n      }\n\n      sendMessage(resp.data, resp, msg)\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, msg)\n    }\n\n    node.on('close', function (done) {\n      if (timerID) {\n        clearInterval(timerID)\n      }\n      timerID = null\n      mbBasics.setNodeStatusTo('closed', node)\n      modbusClient.deregisterForModbus(node, done)\n    })\n\n    function sendMessage (values, response, msg) {\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        if (node.logIOActivities) {\n          mbIOCore.internalDebug('node.adr:' + node.adr + ' node.quantity:' + node.quantity)\n        }\n\n        const allValueNames = mbIOCore.nameValuesFromIOFile(node, msg, values, response, node.adr)\n        const valueNames = mbIOCore.filterValueNames(node, allValueNames, mbCore.functionCodeModbusRead(node.dataType), node.adr, node.quantity)\n\n        const origMsg = {\n          topic: msg.topic,\n          responseBuffer: response,\n          input: msg\n        }\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        node.send([\n          origMsg,\n          {\n            payload: response,\n            values: values,\n            input: msg,\n            valueNames: valueNames\n          }])\n      } else {\n        node.send([\n          {\n            payload: values,\n            responseBuffer: response,\n            input: msg\n          },\n          {\n            payload: response,\n            values: values,\n            input: msg\n          }\n        ])\n      }\n    }\n\n    function setNodeStatusWithTimeTo (statusValue) {\n      if (statusValue === 'polling' && timeoutOccurred) {\n        return\n      }\n\n      const statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n      const statusText = node.statusText\n\n      if (statusValue.search('active') !== -1 || statusValue === 'polling') {\n        const newStatusText = statusOptions.status + getTimeInfo()\n        timeoutOccurred = false\n        if (newStatusText !== statusText) {\n          node.status({\n            fill: statusOptions.fill,\n            shape: statusOptions.shape,\n            text: newStatusText\n          })\n        }\n      } else {\n        const newStatusText = statusOptions.status\n        if (newStatusText !== statusText) {\n          node.status({\n            fill: statusOptions.fill,\n            shape: statusOptions.shape,\n            text: newStatusText\n          })\n        }\n      }\n    }\n\n    function getTimeInfo () {\n      return ' ( ' + node.rate + ' ' + mbBasics.get_timeUnit_name(node.rateUnit) + ' ) '\n    }\n  }\n\n  RED.nodes.registerType('modbus-read', ModbusRead)\n\n  RED.httpAdmin.post('/modbus/read/inject/:id', RED.auth.needsPermission('modbus.inject.write'), function (req, res) {\n    const node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.modbusPollingRead()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('modbusinject.failed', { error: err.toString() }))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}