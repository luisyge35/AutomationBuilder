{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","require","install","mbCore","internalDebugLog","nodes","registerType","config","mbBasics","createNode","this","name","showStatusActivities","unitid","ModbusWrite","dataType","Number","adr","verbose","quantity","node","setNodeStatusTo","getNode","server","modbusClient","registerForModbus","initModbusClientEvents","resp","msg","bufferMessageList","payload","buildMessage","err","message","showErrors","onModbusWriteError","setModbusError","getOriginalMessage","on","invalidPayloadIn","client","Object","call","value","indexOf","prototype","hasOwnProperty","getObjectId","set","messageId","fc","functionCodeModbusWrite","address","emit","onModbusWriteDone","done","clear"],"mappings":"aAeAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,sBAIMG,EAAmBH,QAAQ,QAARA,CAAiB,uBA6FzCD,EAAAK,MAAAC,aAAA,eA3FD,SAAsBC,GAJtBP,EAAMQ,MAAQC,WAAWC,KAAAH,GACzBG,KAAMP,KAASF,EAAQU,KAOrBD,KAAKE,qBAAuBL,EAAOK,qBANrCF,KAAMN,WAAgBG,EAAGN,WAEzBS,KAAAG,OAASC,EAAaP,OACpBP,KAAIK,SAAMI,EAAWM,SAErBL,KAAKC,IAALK,OAAkBT,EAAlBU,KACAP,KAAKE,SAAAA,EAAAA,SAGLF,KAAKG,iBAAgBA,EACrBH,KAAKK,eAAiBf,EAACe,SAAvBG,QAEA,IAAKC,EAALT,KAEAU,EAAKhB,kBAAmBA,IAAAA,IAGxBI,EAAUa,gBAAV,UAAAD,GAGAZ,IAAAA,EAASa,EAAgBhB,MAAAiB,QAAWF,EAApCG,QAEMC,IAEJA,EAAAC,kBAAAL,GACDZ,EAAAkB,uBAAAN,EAAAI,GACDA,EAAAA,kBAAaC,SAAbE,EAAAC,GACApB,EAASkB,sBAILlB,EAASa,gBAAgB,aAAcD,GAAvCZ,EAAAA,KAAQL,EAACkB,aAAgBD,EAAAS,kBAAzBD,EAAAE,QAAAH,EAAAC,KAGFR,EAAAA,mBAAiBW,SAAiBC,EAACH,GALrCzB,EAAA4B,EAAAC,SAUMb,EAAKc,YAFPd,EAACe,MAAAA,EAAAA,GAKH3B,EAAS4B,eAAehB,EAAMI,EAAcQ,EAAK7B,EAAOkC,mBAAmBjB,EAAKS,kBAAmBD,KADlGR,EAAAkB,GAAA,QAAA,SAAAV,GAKGpB,EAAS+B,iBAAiBX,IADhCJ,EAAiBgB,SAKXC,OAACjB,UAAagB,eAAQE,KAAAd,EAAAE,QAAA,UACxB,iBAAAF,EAAAE,QAAAa,QACD,SAAAf,EAAAE,QAAAa,OAAA,UAAAf,EAAAE,QAAAa,MAEDf,EAAAE,QAAAa,MAAA,SAAAf,EAAAE,QAAAa,OAM0C,EAAlCf,EAAIE,QAAQa,MAAMC,QAAQ,OAL9BH,EAAMX,QAACe,MAAUC,KAAAA,MAAeJ,EAAKd,QAAIE,SAMvCF,EAAAA,UAAIE,EAAJiB,cACD3B,EAAAS,kBAAAmB,IAAApB,EAAAqB,UAAArB,GAEJA,EAAA,CAMCE,QAAS,CAJPmB,MAAAA,EAAJnB,QAAuBiB,OAAAA,EAAvBjB,QACIjB,OAACgB,EAAAA,OAEFqB,GAAG/C,EAAAgD,wBAAA/B,EAAAL,UACJe,QAASV,EAAAH,IACP0B,SAAUvB,EAACU,SACXjB,UAAQO,EAAKP,WAEbuC,OAAAA,EAAShC,QAJFI,EADL6B,KAAA,cAAAzB,EAAAR,EAAAkC,kBAAAlC,EAAAe,oBAANf,EAAAR,sBAYAY,EAAAA,gBAAkBA,EAAoBJ,mBAAtCA,MAICA,EAAAkB,GAAA,QAAA,SAAAiB,GAxCH/C,EAAAa,gBAAA,SAAAD,GA2CAA,EAAAS,kBAAiB2B,QACfhD,EAASa,oBAATD,EAAAmC","file":"../modbus-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('write done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') &&\n        typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n\n      msg.messageId = mbCore.getObjectId()\n      node.bufferMessageList.set(msg.messageId, msg)\n\n      msg = {\n        payload: {\n          value: msg.payload.value || msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: msg.messageId\n        },\n        _msgid: msg._msgid\n      }\n\n      modbusClient.emit('writeModbus', msg, node.onModbusWriteDone, node.onModbusWriteError)\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}