{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","config","createNode","this","name","showStatusActivities","showErrors","internalDebugLog","useIOFile","ModbusFlexGetter","getNode","ioFile","useIOForPayload","connection","emptyMsgOnFail","logIOActivities","node","mbBasics","server","bufferMessageList","modbusClient","registerForModbus","onModbusReadDone","resp","msg","buildMessageWithIO","data","onModbusReadError","err","message","error","setModbusError","getOriginalMessage","prepareMsg","payload","fc","parseInt","unitid","address","parse","quantity","isValidModbusMsg","Number","isInteger","isValid","buildNewMessageObject","newMsg","value","id","messageId","on","invalidPayloadIn","client","set","emit","setNodeStatusTo","actualServiceState","clear","deregisterForModbus","done"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      mbBasics.emptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc) || 3\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address) || 0\n      msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.address) &&\n            msg.payload.address >= 0 &&\n            msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.quantity) &&\n            msg.payload.quantity >= 1 &&\n            msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const newMsg = Object.assign({}, msg)\n      newMsg.topic = msg.topic || node.id\n      newMsg.payload = {\n        value: msg.payload.value || msg.value,\n        unitid: msg.payload.unitid,\n        fc: msg.payload.fc,\n        address: msg.payload.address,\n        quantity: msg.payload.quantity,\n        messageId: msg.messageId,\n        emptyMsgOnFail: node.emptyMsgOnFail\n      }\n      return newMsg\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\n        return\n      }\n\n      try {\n        msg = node.prepareMsg(msg)\n        if (node.isValidModbusMsg(msg)) {\n          msg.messageId = mbCore.getObjectId()\n          node.bufferMessageList.set(msg.messageId, msg)\n          const newMsg = node.buildNewMessageObject(node, msg)\n          modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n        }\n      } catch (err) {\n        internalDebugLog(err.message)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n\n        mbBasics.emptyMsgOnFail(node, err, msg)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}