{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","require","install","coreModbusQueue","internalDebugLog","node","registerType","config","mbBasics","createNode","this","name","topic","unitid","lowLowLevel","parseInt","lowLevel","ModbusQueueInfo","nodes","highLevel","highHighLevel","errorOnHighLevel","queueReadIntervalTime","showStatusActivities","updateOnAllQueueChanges","queueReadInterval","getNode","server","updateStatusRrunning","modbusClient","registerForModbus","resetStates","lowLowLevelReached","initModbusClientEvents","highHighLevelReached","items","unit","lowLevelReached","payload","Date","now","checkLowLevelReached","state","modbusClientName","highLevelReached","msg","checkHighLevelReached","error","warn","send","checkHighHighLevelReached","fillColor","getStatusSituationFillColor","readFromQueue","bufferCommands","get","length","bufferCommandList","status","fill","shape","text","setNodeStatusTo","on","setInterval","queue","queueOptions","date","Number","isInteger","lowlowLevel","resetQueue","initQueue","verbose","infoText","settings","done","clearInterval","deregisterForModbus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid)\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.resetStates = function () {\n      node.lowLowLevelReached = true\n      node.lowLevelReached = false\n      node.highLevelReached = false\n      node.highHighLevelReached = false\n    }\n\n    node.resetStates()\n\n    node.checkLowLevelReached = function (node, items, unit) {\n      if (!node.lowLevelReached && items > node.lowLowLevel && items < node.lowLevel) {\n        node.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          items: items\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, items, unit) {\n      if (!node.highLevelReached && items > node.lowLevel && items > node.highLevel) {\n        node.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          highLevel: node.highLevel,\n          items: items\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, items, unit) {\n      if (!node.highHighLevelReached && items > node.highLevel && items > node.highHighLevel) {\n        node.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          items: items\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function () {\n      let fillColor = 'blue'\n\n      if (node.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (node.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (node.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      node.updateStatusRrunning = true\n      let unit = node.unitid || 1\n\n      if (modbusClient.bufferCommands) {\n        if (unit < 1 || unit > 255) {\n          unit = 1\n        }\n\n        const items = modbusClient.bufferCommandList.get(unit).length\n        if (!items || (!node.lowLowLevelReached && items < node.lowLowLevel)) {\n          node.resetStates()\n        }\n\n        node.checkLowLevelReached(node, items, unit)\n        node.checkHighLevelReached(node, items, unit)\n        node.checkHighHighLevelReached(node, items, unit)\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: node.getStatusSituationFillColor(),\n            shape: 'ring',\n            text: 'active unit ' + unit + ' queue items: ' + items\n          })\n        }\n      } else if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('active unit ' + unit + ' without queue', node)\n      }\n      node.updateStatusRrunning = false\n    }\n\n    modbusClient.on('mbinit', node.readFromQueue)\n    modbusClient.on('mbconnected', node.readFromQueue)\n    modbusClient.on('mberror', node.readFromQueue)\n    if (node.updateOnAllQueueChanges) { // more CPU-Load on many requests\n      modbusClient.on('mbactive', node.readFromQueue)\n    }\n    modbusClient.on('mbclosed', node.readFromQueue)\n\n    node.queueReadInterval = setInterval(node.readFromQueue, node.queueReadIntervalTime)\n\n    node.on('input', function (msg) {\n      msg.queueEnabled = modbusClient.bufferCommands\n\n      if (Number.isInteger(node.unitid)) {\n        msg.queue = modbusClient.bufferCommandList.get(node.unitid)\n        msg.unitid = node.unitid\n      } else {\n        msg.queues = modbusClient.bufferCommandList\n      }\n\n      msg.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name,\n        lowlowLevel: node.lowlowLevel,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      if (msg && msg.resetQueue && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.resetStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}